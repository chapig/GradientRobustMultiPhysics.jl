<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PDE Description · GradientRobustMultiPhysics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GradientRobustMultiPhysics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">FE Spaces and Arrays</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li class="is-active"><a class="tocitem" href>PDE Description</a><ul class="internal"><li><a class="tocitem" href="#Purpose"><span>Purpose</span></a></li><li><a class="tocitem" href="#Creating/Extending-a-PDEDescription"><span>Creating/Extending a PDEDescription</span></a></li><li><a class="tocitem" href="#PDE-Operators"><span>PDE Operators</span></a></li><li><a class="tocitem" href="#Nonlinear-Operators"><span>Nonlinear Operators</span></a></li><li><a class="tocitem" href="#Global-Constraints"><span>Global Constraints</span></a></li><li><a class="tocitem" href="#Dirichlet-Boundary-Data"><span>Dirichlet Boundary Data</span></a></li><li><a class="tocitem" href="#Other-Boundary-Data"><span>Other Boundary Data</span></a></li></ul></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li><li><a class="tocitem" href="../pdesolvers/">PDE Solvers</a></li><li><a class="tocitem" href="../abstractactions/">AbstractActions</a></li><li><a class="tocitem" href="../assemblypatterns/">AbstractAssemblyPatterns</a></li><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li><a class="tocitem" href="../viewers/">Export/Viewers</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">How to run the examples</a></li><li><a class="tocitem" href="../examples/doc_1d_bestapprox/">1D L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_bestapprox_divpreserve/">2D Divergence-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_commutinginterpolators/">2D Commuting Interpolators</a></li><li><a class="tocitem" href="../examples/doc_2d_compressiblestokes/">2D Compressible Stokes</a></li><li><a class="tocitem" href="../examples/doc_2d_convectiondiffusion/">2D Convection-Diffusion-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_cookmembrane/">2D Linear Elasticity</a></li><li><a class="tocitem" href="../examples/doc_2d_flowtransport/">2D Flow + Transport</a></li><li><a class="tocitem" href="../examples/doc_2d_hagenpoiseuille/">2D Hagen-Poiseuille (Navier–Stokes)</a></li><li><a class="tocitem" href="../examples/doc_2d_jumpestimator/">2D Jump-Estimator</a></li><li><a class="tocitem" href="../examples/doc_2d_liddrivencavity_anderson/">2D Lid-driven cavity (Anderson-Iteration)</a></li><li><a class="tocitem" href="../examples/doc_2d_liddrivencavity_autonewton/">2D Lid-driven cavity (AD-Newton)</a></li><li><a class="tocitem" href="../examples/doc_2d_stokes_probust/">2D Pressure-robustness</a></li><li><a class="tocitem" href="../examples/doc_2d_transientstokes/">2D Transient Stokes-Problem</a></li><li><a class="tocitem" href="../examples/doc_3d_elasticity/">3D Linear Elasticity</a></li><li><a class="tocitem" href="../examples/doc_3d_poisson/">3D Poisson-Problem</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>PDE Description</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PDE Description</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/pdedescription.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PDE-Description"><a class="docs-heading-anchor" href="#PDE-Description">PDE Description</a><a id="PDE-Description-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-Description" title="Permalink"></a></h1><h2 id="Purpose"><a class="docs-heading-anchor" href="#Purpose">Purpose</a><a id="Purpose-1"></a><a class="docs-heading-anchor-permalink" href="#Purpose" title="Permalink"></a></h2><p>Although a more manually low-level assembly of your problem is possible, it is advised to describe it in the form of a PDEDescription to get access to certain automated mechanisms (in particular concerning solvers). The PDEDescription has similarities with the weak form of your problem (without time derivatives that are added separately) and in general does not need any information on the discretisation at this point.</p><p>The following flow chart summarises the assemble process that is run during the solve process. The green parts can be modified/specified by the user, the rest is handled automatically. For details on steering the solver see <a href="../pdesolvers/#PDE-Solvers">PDE Solvers</a></p><p><img src="../assembly_flowchart.png" alt="Assembly Flowchart"/> </p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEDescription" href="#GradientRobustMultiPhysics.PDEDescription"><code>GradientRobustMultiPhysics.PDEDescription</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct PDEDescription
    name::String
    equation_names::Array{String,1}
    unknown_names::Array{String,1}
    LHS::Array{Array{AbstractPDEOperator,1},2}
    RHS::Array{Array{AbstractPDEOperator,1},1}
    BoundaryOperators::Array{BoundaryOperator,1}
    GlobalConstraints::Array{AbstractGlobalConstraint,1}
end</code></pre><p>struct that describes a PDE system with n equations and n unknowns</p><p>A PDE system is described by</p><ul><li>its name</li><li>the names of its equations</li><li>the names of its unknowns</li><li>a size n x n array of Array{AbstractPDEOperator,1} LHS that describes the left-hand sides</li><li>a length n array of Array{AbstractPDEOperator,1} RHS that describes the right-hand sides</li><li>a length n array of BoundaryOperators that describes the boundary conditions for each unknown</li><li>an array of GlobalConstraints that describes additional global constraints</li></ul><p>A PDEDescription mainly is a set of PDEOperators arranged in a quadratic n by n matrix. Every matrix row refers to one equation and the positioning of the PDEOperators (e.g. a bilinearform) immediately sets the information which unknowns have to be used to evaluate the operator. Also  nonlinear PDEOperators are possible where extra information on the further involved uknowns have to be specified. UserData is also assigned to the PDEDescription depending on their type. Operator coefficients are assigned directly to the PDEOperators (in form of AbstractActions), right-hand side data is assigned to the right-hand side array of PDEOperators and boundary data is assigned to the BoundaryOperators of the PDEDescription. Additionaly global constraints (like a global zero integral mean) can be assigned as a GlobalConstraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L2-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,PDEDescription}" href="#Base.show-Tuple{IO,PDEDescription}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show(io::IO, PDE::PDEDescription)
</code></pre><p>Custom <code>show</code> function for <code>PDEDescription</code> that prints the PDE systems and all assigned operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L169">source</a></section></article><h2 id="Creating/Extending-a-PDEDescription"><a class="docs-heading-anchor" href="#Creating/Extending-a-PDEDescription">Creating/Extending a PDEDescription</a><a id="Creating/Extending-a-PDEDescription-1"></a><a class="docs-heading-anchor-permalink" href="#Creating/Extending-a-PDEDescription" title="Permalink"></a></h2><p>Several add...! functions allow to extend the problems at any stage. There are several prototype PDEs documented on the <a href="../pdeprototypes/#PDE-Prototypes">PDE Prototypes</a> page that can be used as a point of departure. Below is a list of functions that allows to initialise and extend a PDEDescription.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEDescription" href="#GradientRobustMultiPhysics.PDEDescription"><code>GradientRobustMultiPhysics.PDEDescription</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PDEDescription(name::String, nunknowns::Int64, ncomponents::Array{Int64,1}) -&gt; PDEDescription
PDEDescription(name::String, nunknowns::Int64, ncomponents::Array{Int64,1}, dim::Int64; unknown_names, equation_names) -&gt; PDEDescription
</code></pre><p>Create empty PDEDescription for a specified number of unknowns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEDescription-Tuple{String}" href="#GradientRobustMultiPhysics.PDEDescription-Tuple{String}"><code>GradientRobustMultiPhysics.PDEDescription</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PDEDescription(name::String) -&gt; PDEDescription
</code></pre><p>Create empty PDEDescription with no unknowns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_boundarydata!-Tuple{PDEDescription,Int64,Any,Type{var&quot;#s357&quot;} where var&quot;#s357&quot;&lt;:AbstractBoundaryType}" href="#GradientRobustMultiPhysics.add_boundarydata!-Tuple{PDEDescription,Int64,Any,Type{var&quot;#s357&quot;} where var&quot;#s357&quot;&lt;:AbstractBoundaryType}"><code>GradientRobustMultiPhysics.add_boundarydata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_boundarydata!(PDE::PDEDescription, position::Int64, regions::Any, btype::Type{var&quot;#s357&quot;} where var&quot;#s357&quot;&lt;:AbstractBoundaryType; data, bonus_quadorder) -&gt; Union{Nothing, Bool}
</code></pre><p>Adds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.</p><p>If timedependent == true, that data function depends also on time t and is reassembled in any advance! step of a TimeControlSolver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_constraint!-Tuple{PDEDescription,AbstractGlobalConstraint}" href="#GradientRobustMultiPhysics.add_constraint!-Tuple{PDEDescription,AbstractGlobalConstraint}"><code>GradientRobustMultiPhysics.add_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint) -&gt; Array{AbstractGlobalConstraint,1}
</code></pre><p>Adds the given global constraint to the PDEDescription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription,Array{Int64,1},GradientRobustMultiPhysics.AbstractPDEOperatorLHS}" href="#GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription,Array{Int64,1},GradientRobustMultiPhysics.AbstractPDEOperatorLHS}"><code>GradientRobustMultiPhysics.add_operator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_operator!(PDE::PDEDescription, position::Array{Int64,1}, O::GradientRobustMultiPhysics.AbstractPDEOperatorLHS; equation_name) -&gt; Union{Nothing, Array{AbstractPDEOperator,1}}
</code></pre><p>Adds the given PDEOperator to the left-hand side of the PDEDescription at the specified position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_rhsdata!-Tuple{PDEDescription,Int64,AbstractPDEOperator}" href="#GradientRobustMultiPhysics.add_rhsdata!-Tuple{PDEDescription,Int64,AbstractPDEOperator}"><code>GradientRobustMultiPhysics.add_rhsdata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_rhsdata!(PDE::PDEDescription, position::Int64, O::AbstractPDEOperator) -&gt; Array{AbstractPDEOperator,1}
</code></pre><p>Adds the given PDEOperator to the right-hand side of the PDEDescription at the specified position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_unknown!" href="#GradientRobustMultiPhysics.add_unknown!"><code>GradientRobustMultiPhysics.add_unknown!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_unknown!(PDE::PDEDescription, ncomponents::Int64) -&gt; Array{Array{AbstractPDEOperator,1},2}
add_unknown!(PDE::PDEDescription, ncomponents::Int64, dim::Int64; equation_name, unknown_name) -&gt; Array{Array{AbstractPDEOperator,1},2}
</code></pre><p>Adds another unknown of specified dimensions to the PDEDescription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L95">source</a></section></article><h2 id="PDE-Operators"><a class="docs-heading-anchor" href="#PDE-Operators">PDE Operators</a><a id="PDE-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-Operators" title="Permalink"></a></h2><p>The PDE consists of PDEOperators characterising some feature of the model (like friction, convection, exterior forces etc.), they describe the continuous weak form of the PDE. The following table lists all available operators and physics-motivated constructors for them. Click on them to find out more details.</p><table><tr><th style="text-align: left">PDEOperator subtype</th><th style="text-align: left">Special constructors</th><th style="text-align: left">Mathematically</th></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.AbstractBilinearForm"><code>AbstractBilinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{A}(\mathrm{FO}_1(u)),\mathrm{FO}_2(v))$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.LaplaceOperator"><code>LaplaceOperator</code></a></td><td style="text-align: left"><span>$(\kappa \nabla u,\nabla v)$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ReactionOperator"><code>ReactionOperator</code></a></td><td style="text-align: left"><span>$(\alpha u, v)$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionOperator"><code>ConvectionOperator</code></a></td><td style="text-align: left"><span>$(\beta \cdot \nabla u, v)$</span> (beta is function)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.HookStiffnessOperator2D"><code>HookStiffnessOperator2D</code></a></td><td style="text-align: left"><span>$(\mathbb{C} \epsilon(u),\epsilon(v))$</span></td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.AbstractTrilinearForm"><code>AbstractTrilinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{A}(\mathrm{FO}_1(a),\mathrm{FO}_2(u)),\mathrm{FO}_3(v))$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionOperator"><code>ConvectionOperator</code></a></td><td style="text-align: left"><span>$(a \cdot \nabla u, v)$</span> (a is registered unknown)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionRotationFormOperator"><code>ConvectionRotationFormOperator</code></a></td><td style="text-align: left"><span>$(a x curl(u),v)$</span> (a is registered unknown, only 2D for now)</td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.AbstractMultilinearForm"><code>AbstractMultilinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GenerateNonlinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{NA}(\mathrm{FO}_1(u)),\mathrm{FO}_3(v))$</span></td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.RhsOperator"><code>RhsOperator</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(f \cdot \mathrm{FO}(v))$</span></td></tr></table><p>Legend: <span>$\mathrm{FO}$</span>  are placeholders for <a href="../functionoperators/#Function-Operators">Function Operators</a>, and <span>$\mathrm{A}$</span> stands for a (linear) <a href="../abstractactions/#Abstract-Actions">Abstract Actions</a> (that only expects the operator value of the finite element function as an input) and <span>$\mathrm{NA}$</span> stands for a (nonlinear) <a href="../abstractactions/#Abstract-Actions">Abstract Actions</a> (see <a href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GenerateNonlinearForm</code></a> for details).</p><h3 id="Linear-Operators"><a class="docs-heading-anchor" href="#Linear-Operators">Linear Operators</a><a id="Linear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Operators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AbstractBilinearForm" href="#GradientRobustMultiPhysics.AbstractBilinearForm"><code>GradientRobustMultiPhysics.AbstractBilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">function AbstractBilinearForm(name,
    operator1::Type{&lt;:AbstractFunctionOperator},
    operator2::Type{&lt;:AbstractFunctionOperator},
    action::AbstractAction;
    apply_action_to = 1,
    regions::Array{Int,1} = [0],
    transposed_assembly::Bool = false)</code></pre><p>abstract bilinearform operator that assembles</p><ul><li>b(u,v) = int<em>regions action(operator1(u)) * operator2(v) if apply</em>action_to = 1</li><li>b(u,v) = int<em>regions operator1(u) * action(operator2(v)) if apply</em>action_to = 2</li></ul><p>can only be applied in PDE LHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L87-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AbstractTrilinearForm" href="#GradientRobustMultiPhysics.AbstractTrilinearForm"><code>GradientRobustMultiPhysics.AbstractTrilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct AbstractTrilinearForm{AT&lt;:AbstractAssemblyType} &lt;: AbstractPDEOperatorLHS
    name::String
    operator1::Type{&lt;:AbstractFunctionOperator} # operator for argument 1
    operator2::Type{&lt;:AbstractFunctionOperator} # operator for argument 1
    operator3::Type{&lt;:AbstractFunctionOperator} # operator for argument 1
    a_from::Int     # unknown id where fixed argument takes its values from
    a_to::Int       # position of fixed argument
    action::AbstractAction # is applied to argument 1 and 2
    regions::Array{Int,1}
    transposed_assembly::Bool
end</code></pre><p>abstract trilinearform operator that assembles</p><ul><li>c(a,u,v) = int<em>regions action(operator1(a) * operator2(u))*operator3(v)   (if a</em>to = 1)</li><li>c(u,a,v) = int<em>regions action(operator1(u) * operator2(a))*operator3(v)   (if a</em>to = 2)</li></ul><p>where a_from is the id of one of the unknowns of the PDEsystem</p><p>can only be applied in PDE LHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L395-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AbstractMultilinearForm" href="#GradientRobustMultiPhysics.AbstractMultilinearForm"><code>GradientRobustMultiPhysics.AbstractMultilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct AbstractMultilinearForm{AT&lt;:AbstractAssemblyType} &lt;: AbstractPDEOperatorLHS
    name::String
    operators::Array{DataType,1}
    action::AbstractAction
    regions::Array{Int,1}
end</code></pre><p>abstract multi-linearform with arbitrary many argument of the form</p><p>m(v1,v2,...,vk) = (A(O(v1),O(v2),...,O(vk-1)),Ok(vk))</p><p>(so far only intended for use as RHSOperator together with MLFeval)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L236-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LaplaceOperator" href="#GradientRobustMultiPhysics.LaplaceOperator"><code>GradientRobustMultiPhysics.LaplaceOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>constructor for AbstractBilinearForm that describes a(u,v) = (kappa * nabla u, nabla v) where kappa is some constant diffusion coefficient</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ReactionOperator" href="#GradientRobustMultiPhysics.ReactionOperator"><code>GradientRobustMultiPhysics.ReactionOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ReactionOperator(action::AbstractAction; apply_action_to, identity_operator, regions) -&gt; AbstractBilinearForm{ON_CELLS}
</code></pre><p>constructor for AbstractBilinearForm that describes a(u,v) = (A(u),v) or (u,A(v)) with some user-specified action A</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ConvectionOperator" href="#GradientRobustMultiPhysics.ConvectionOperator"><code>GradientRobustMultiPhysics.ConvectionOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ConvectionOperator(beta::Function, xdim::Int64, ncomponents::Int64; bonus_quadorder, testfunction_operator, regions) -&gt; AbstractBilinearForm{ON_CELLS}
</code></pre><p>constructor for AbstractBilinearForm that describes a(u,v) = (beta*grad(u),v) with some user-specified function beta with the interface beta(result,x) (so it writes its result into result and returns nothing)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L209">source</a></section><section><div><pre><code class="language-julia">ConvectionOperator(a_from::Int64, beta_operator::Any, xdim::Int64, ncomponents::Int64; fixed_argument, testfunction_operator, regions) -&gt; AbstractTrilinearForm{ON_CELLS}
</code></pre><p>constructor for AbstractBilinearForm that describes a(u,v) = (beta*grad(u),v) where beta is the id of some unknown of the PDEDescription. With fixed_argument = 2 beta and u can siwtch their places.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ConvectionRotationFormOperator" href="#GradientRobustMultiPhysics.ConvectionRotationFormOperator"><code>GradientRobustMultiPhysics.ConvectionRotationFormOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ConvectionRotationFormOperator(beta::Int64, beta_operator::Type{var&quot;#s354&quot;} where var&quot;#s354&quot;&lt;:AbstractFunctionOperator, xdim::Int64, ncomponents::Int64; testfunction_operator, regions) -&gt; AbstractTrilinearForm{ON_CELLS}
</code></pre><p>constructor for AbstractBilinearForm that describes a(u,v) = (beta x curl(u),v) where beta is the id of some unknown vector field of the PDEDescription, u and v are also vector-fields and x is the cross product (so far this is only implemented in 2D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator1D" href="#GradientRobustMultiPhysics.HookStiffnessOperator1D"><code>GradientRobustMultiPhysics.HookStiffnessOperator1D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator1D(mu::Real; regions, gradient_operator) -&gt; AbstractBilinearForm{ON_CELLS}
</code></pre><p>constructor for AbstractBilinearForm that describes a(u,v) = (C grad(u), grad(v)) where C is the 1D stiffness tensor C grad(u) = mu grad(u)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator2D" href="#GradientRobustMultiPhysics.HookStiffnessOperator2D"><code>GradientRobustMultiPhysics.HookStiffnessOperator2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator2D(mu::Real, lambda::Real; regions, gradient_operator) -&gt; AbstractBilinearForm{ON_CELLS}
</code></pre><p>constructor for AbstractBilinearForm that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda</p><pre><code class="language-none">In Voigt notation C is a 3 x 3 matrix
C = [c11,c12,  0
     c12,c11,  0
       0,  0,c33]

where c33 = shear_modulus, c12 = lambda and c11 = 2*c33 + c12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator3D" href="#GradientRobustMultiPhysics.HookStiffnessOperator3D"><code>GradientRobustMultiPhysics.HookStiffnessOperator3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator3D(mu::Real, lambda::Real; regions, gradient_operator) -&gt; AbstractBilinearForm{ON_CELLS}
</code></pre><p>constructor for AbstractBilinearForm that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda</p><pre><code class="language-none">In Voigt notation C is a 6 x 6 matrix
C = [c11,c12,c12,  0,  0,  0
     c12,c11,c12,  0,  0,  0
     c12,c12,c11,  0,  0,  0
       0,  0,  0,c44,  0,  0
       0,  0,  0,  0,c44,  0
       0,  0,  0,  0,  0,c44]   

where c44 = shear_modulus, c12 = lambda and c11 = 2*c44 + c12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BLFeval" href="#GradientRobustMultiPhysics.BLFeval"><code>GradientRobustMultiPhysics.BLFeval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BLFeval &lt;: AbstractPDEOperatorRHS
    BLF::AbstractBilinearForm
    Data::FEVectorBlock
    factor::Real
    nonlinear::Bool
    timedependent::Bool
end</code></pre><p>evaluation of a AbstractBilinearForm BLF (multiplied by a factor) where the second argument is fixed by given FEVectorBlock Data.</p><p>The operator can be manually marked as nonlinear or time-dependent to trigger reassembly at each iteration or each timestep.</p><p>can only be applied in PDE RHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L545-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.TLFeval" href="#GradientRobustMultiPhysics.TLFeval"><code>GradientRobustMultiPhysics.TLFeval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TLFeval &lt;: AbstractPDEOperatorRHS
    TLF::AbstractTrilinearForm
    Data1::FEVectorBlock
    Data2::FEVectorBlock
    factor::Real
    nonlinear::Bool
    timedependent::Bool
end</code></pre><p>evaluation of a AbstractTrilinearForm TLF (multiplied by a factor) where the first and second argument are fixed by given FEVectorBlocks Data1 and Data2.</p><p>The operator can be manually marked as nonlinear or time-dependent to trigger reassembly at each iteration or each timestep.</p><p>can only be applied in PDE RHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L575-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.MLFeval" href="#GradientRobustMultiPhysics.MLFeval"><code>GradientRobustMultiPhysics.MLFeval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MLFeval &lt;: AbstractPDEOperatorRHS
    MLF::AbstractMultilinearForm
    Data::Array{FEVectorBlock,1}
    factor::Real
    nonlinear::Bool
    timedependent::Bool
end</code></pre><p>evaluation of a AbstractMultilinearForm MLF (multiplied by a factor) where all but the last argument are fixed by given FEVectorBlocks in the array Data.</p><p>The operator can be manually marked as nonlinear or time-dependent to trigger reassembly at each iteration or each timestep.</p><p>can only be applied in PDE RHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L607-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.RhsOperator" href="#GradientRobustMultiPhysics.RhsOperator"><code>GradientRobustMultiPhysics.RhsOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct RhsOperator{AT&lt;:AbstractAssemblyType} &lt;: AbstractPDEOperatorRHS
    rhsfunction::Function
    testfunction_operator::Type{&lt;:AbstractFunctionOperator}
    timedependent::Bool
    regions::Array{Int,1}
    xdim:: Int
    ncomponents:: Int
    bonus_quadorder:: Int
    store_operator::Bool                    # should the vector of the operator be stored?
    storage::AbstractArray{Float64,1}       # vector can be stored here to allow for fast reassembly in iterative settings
end</code></pre><p>right-hand side operator</p><p>can only be applied in PDE RHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L488-L506">source</a></section></article><h2 id="Nonlinear-Operators"><a class="docs-heading-anchor" href="#Nonlinear-Operators">Nonlinear Operators</a><a id="Nonlinear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Operators" title="Permalink"></a></h2><p>It is possible to assign nonlinear operators in such a way that its Jacobian can be computed by automatic differentation to setup a Newton scheme, see below for details.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.GenerateNonlinearForm" href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GradientRobustMultiPhysics.GenerateNonlinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function GenerateNonlinearForm(
    name::String,
    operator1::Array{DataType,1},
    coeff_from::Array{Int,1},
    operator2::Type{&lt;:AbstractFunctionOperator},
    action_kernel::Function,
    argsizes::Array{Int,1},
    dim::Int;
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    ADnewton::Bool = false,
    action_kernel_rhs = nothing,
    regions = [0])</code></pre><p>generates an abstract nonlinearform operator G.  The array coeff_from stores the ids of the unknowns that should be used to evaluate the operators. The array argsizes is a vector with two entries where the first one is the length of the expected result vector and the second one is the length of the input vector.</p><p>If ADnewton == true, the specified action<em>kernel is automatically differentiated to assemble the Jacobian DG and setup a Newton iteration. The action</em>kernel has to be a function of the interface </p><pre><code class="language-none">function name(result,input)</code></pre><p>where input is a vector of the operators of the solution and result is what then is multiplied with operator2 of the testfunction. Given some operator G(u), the Newton iteration reads DG u_next = DG u - G(u) which is added to the rest of the (linear) operators in the PDEDescription.</p><p>If ADnewton == false, the user is epected to prescribe a linearisation of the nonlinear operator. In this case the action_kernel has to satisfy the interface</p><pre><code class="language-none">function name(result, input_current, input_ansatz)</code></pre><p>where input<em>current is a vector of the operators of the solution and input</em>ansatz is a vecor with the operators evaluated at one of the basis functions. If necessary, also a right-hand side action in the same format can be prescribed in action<em>kernel</em>rhs.</p><p>Note: this is a highly experimental feature at the moment and will possibly only work when all operators are associated with the same unknown.</p><p>can only be applied in PDE LHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdeoperators.jl#L272-L311">source</a></section></article><h2 id="Global-Constraints"><a class="docs-heading-anchor" href="#Global-Constraints">Global Constraints</a><a id="Global-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Constraints" title="Permalink"></a></h2><p>GlobalConstraints are additional constraints that the user does not wish to implement as a global Lagrange multiplier because it e.g. causes a dense row in the system matrix and therefore may destroy the performance of the sparse matrix routines. Such a constraint may be a fixed integral mean. Another application are periodic boundary conditions or glued-together quantities in different regions of the grid. Here a CombineDofs constraint may help.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.CombineDofs" href="#GradientRobustMultiPhysics.CombineDofs"><code>GradientRobustMultiPhysics.CombineDofs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CombineDofs &lt;: AbstractGlobalConstraint</code></pre><p>combines specified degrees of freedom of two unknown (can be the same), which allows to glue together different unknowns in different regions or periodic boundary conditions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/globalconstraints.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.FixedIntegralMean" href="#GradientRobustMultiPhysics.FixedIntegralMean"><code>GradientRobustMultiPhysics.FixedIntegralMean</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FixedIntegralMean &lt;: AbstractGlobalConstraint</code></pre><p>fixes integral mean of the unknown to the specified value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/globalconstraints.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_constraint!" href="#GradientRobustMultiPhysics.add_constraint!"><code>GradientRobustMultiPhysics.add_constraint!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint) -&gt; Array{AbstractGlobalConstraint,1}
</code></pre><p>Adds the given global constraint to the PDEDescription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L159">source</a></section></article><h2 id="Dirichlet-Boundary-Data"><a class="docs-heading-anchor" href="#Dirichlet-Boundary-Data">Dirichlet Boundary Data</a><a id="Dirichlet-Boundary-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-Boundary-Data" title="Permalink"></a></h2><p>BoundaryOperators carry the boundary data for each unknown. Each regions can have a different AbstractBoundaryType and an associated data function that satisfies the interface function data!(result,x) or function data!(result,x,t) if it is also time-dependent.</p><table><tr><th style="text-align: left">AbstractBoundaryType</th><th style="text-align: left">Subtypes</th><th style="text-align: left">causes</th></tr><tr><td style="text-align: left"><a href="@ref"><code>DirichletBoundary</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="@ref"><code>BestapproxDirichletBoundary</code></a></td><td style="text-align: left">computation of Dirichlet data by bestapproximation along boundary faces</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="@ref"><code>InterpolateDirichletBoundary</code></a></td><td style="text-align: left">computation of Dirichlet data by interpolation along boundary faces</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="@ref"><code>HomogeneousDirichletBoundary</code></a></td><td style="text-align: left">zero Dirichlet data on all dofs</td></tr></table><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BoundaryOperator" href="#GradientRobustMultiPhysics.BoundaryOperator"><code>GradientRobustMultiPhysics.BoundaryOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BoundaryOperator &lt;: AbstractPDEOperator</code></pre><p>collects boundary data for a component of the system and allows to specify a AbstractBoundaryType for each boundary region so far only DirichletBoundary types (see above)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/boundarydata.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_boundarydata!" href="#GradientRobustMultiPhysics.add_boundarydata!"><code>GradientRobustMultiPhysics.add_boundarydata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_boundarydata!(PDE::PDEDescription, position::Int64, regions::Any, btype::Type{var&quot;#s357&quot;} where var&quot;#s357&quot;&lt;:AbstractBoundaryType; data, bonus_quadorder) -&gt; Union{Nothing, Bool}
</code></pre><p>Adds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.</p><p>If timedependent == true, that data function depends also on time t and is reassembled in any advance! step of a TimeControlSolver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/26b490e18cc5a9308c5e4c5537ca4d3436db392b/src/pdedescription.jl#L147">source</a></section></article><h2 id="Other-Boundary-Data"><a class="docs-heading-anchor" href="#Other-Boundary-Data">Other Boundary Data</a><a id="Other-Boundary-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Boundary-Data" title="Permalink"></a></h2><p>NeumannBoundary can be implemented as a RhsOperator with on_boundary = true</p><p>PeriodicBoundary can be implemented as a CombineDofs &lt;: AbstractGlobalConstraint</p><p>SymmetryBoundary can be implemented by penalisation as a AbstractBilinearForm on BFaces and specified boundary regions with operator NormalFlux + MultiplyScalarAction(penalty).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functionoperators/">« Function Operators</a><a class="docs-footer-nextpage" href="../pdeprototypes/">PDE Prototypes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 28 September 2020 11:50">Monday 28 September 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
