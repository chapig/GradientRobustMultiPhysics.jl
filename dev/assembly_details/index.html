<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assembly Details · GradientRobustMultiPhysics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GradientRobustMultiPhysics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">FE Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">FE Interpolation</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li><li><a class="tocitem" href="../pdesolvers/">PDE Solvers</a></li><li><a class="tocitem" href="../userdata/">User Data</a></li><li class="is-active"><a class="tocitem" href>Assembly Details</a><ul class="internal"><li><a class="tocitem" href="#Assembly-Types"><span>Assembly Types</span></a></li><li><a class="tocitem" href="#Assembly-Patterns"><span>Assembly Patterns</span></a></li></ul></li><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li><a class="tocitem" href="../viewers/">Export/Viewers</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">How to run the examples</a></li><li><a class="tocitem" href="../examples/doc_1d_bestapprox/">1D L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_bestapprox_curlpreserve/">2D Curl-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_commutinginterpolators/">Commuting Interpolators (2D)</a></li><li><a class="tocitem" href="../examples/doc_2d_compressiblestokes/">2D Compressible Stokes</a></li><li><a class="tocitem" href="../examples/doc_2d_convectiondiffusion/">2D Convection-Diffusion-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_cookmembrane/">2D Linear Elasticity</a></li><li><a class="tocitem" href="../examples/doc_2d_flowtransport/">2D Flow + Transport</a></li><li><a class="tocitem" href="../examples/doc_2d_hagenpoiseuille/">2D Hagen-Poiseuille (Navier–Stokes)</a></li><li><a class="tocitem" href="../examples/doc_2d_liddrivencavity_anderson/">2D Lid-driven cavity (Anderson-Iteration)</a></li><li><a class="tocitem" href="../examples/doc_2d_liddrivencavity_autonewton/">2D Lid-driven cavity (AD-Newton)</a></li><li><a class="tocitem" href="../examples/doc_2d_lshape_adaptivity/">2D Adaptive Mesh Refinement (L-shape)</a></li><li><a class="tocitem" href="../examples/doc_2d_lshape_adaptivity_eq/">2D Equilibration Error Estimation (L-shape)</a></li><li><a class="tocitem" href="../examples/doc_2d_nonlin_poisson/">2D Nonlinear Poisson-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_stokes_probust/">2D Pressure-robustness</a></li><li><a class="tocitem" href="../examples/doc_2d_transientstokes/">2D Transient Stokes-Problem</a></li><li><a class="tocitem" href="../examples/doc_3d_bestapprox_divpreserve/">3D Divergence-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_3d_commutinginterpolators/">Commuting Interpolators (3D)</a></li><li><a class="tocitem" href="../examples/doc_3d_elasticity/">3D Linear Elasticity</a></li><li><a class="tocitem" href="../examples/doc_3d_poisson/">3D Poisson-Problem</a></li><li><a class="tocitem" href="../examples/doc_rational_massmatrix/">Rational Mass Matrix</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Assembly Details</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assembly Details</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/assembly_details.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assembly-Details"><a class="docs-heading-anchor" href="#Assembly-Details">Assembly Details</a><a id="Assembly-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Details" title="Permalink"></a></h1><p>The assembly of an operator is essentially based on a combination of <a href="#Assembly-Types">Assembly Types</a> and <a href="#Assembly-Patterns">Assembly Patterns</a>. The assembly type mainly allows to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.</p><h2 id="Assembly-Types"><a class="docs-heading-anchor" href="#Assembly-Types">Assembly Types</a><a id="Assembly-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Types" title="Permalink"></a></h2><p>The following assembly types are available.</p><table><tr><th style="text-align: left">AssemblyType</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">ON_CELLS</td><td style="text-align: left">assembles over the cells of the mesh</td></tr><tr><td style="text-align: left">ON_FACES</td><td style="text-align: left">assembles over all faces of the mesh</td></tr><tr><td style="text-align: left">ON_IFACES (*)</td><td style="text-align: left">assembles over the interior faces of the mesh</td></tr><tr><td style="text-align: left">ON_BFACES</td><td style="text-align: left">assembles over the boundary faces of the mesh</td></tr><tr><td style="text-align: left">ON_EDGES (*)</td><td style="text-align: left">assembles over all edges of the mesh (in 3D)</td></tr><tr><td style="text-align: left">ON_BEDGES (*)</td><td style="text-align: left">assembles over the boundary edges of the mesh (in 3D)</td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>(*) = still experimental, might have some issues</p></div></div><h2 id="Assembly-Patterns"><a class="docs-heading-anchor" href="#Assembly-Patterns">Assembly Patterns</a><a id="Assembly-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Patterns" title="Permalink"></a></h2><p>Each Pattern comes with a number of arguments/quantities with associated <a href="../functionoperators/#Function-Operators">Function Operators</a> as well as one of the <a href="#Assembly-Types">Assembly Types</a> that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Moreover, patterns can have <a href="@ref">Abstract Actions</a> that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has two implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed).</p><p>The patterns are used by the assembly of the PDE operators defined in a <a href="../pdedescription/#PDE-Description">PDE Description</a>. However, it is also possible for the user to use them directly, see e.g. the example <a href="../examples/doc_2d_commutinginterpolators/#Commuting-Interpolators-(2D)">Commuting Interpolators (2D)</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AbstractAssemblyPattern" href="#GradientRobustMultiPhysics.AbstractAssemblyPattern"><code>GradientRobustMultiPhysics.AbstractAssemblyPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractAssemblyPattern</code></pre><p>abstract type for assembly patterns</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BilinearForm" href="#GradientRobustMultiPhysics.BilinearForm"><code>GradientRobustMultiPhysics.BilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BilinearForm{T&lt;:Real, AT&lt;:AbstractAssemblyType} &lt;: AbstractAssemblyPattern{T&lt;:Real,AT&lt;:AbstractAssemblyType}</code></pre><p>assembly pattern bilinear form (that depends on two quantities)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BilinearForm-Tuple{Type{var&quot;#s107&quot;} where var&quot;#s107&quot;&lt;:Real,Type{var&quot;#s106&quot;} where var&quot;#s106&quot;&lt;:AbstractAssemblyType,FESpace,FESpace,Type{var&quot;#s105&quot;} where var&quot;#s105&quot;&lt;:AbstractFunctionOperator,Type{var&quot;#s104&quot;} where var&quot;#s104&quot;&lt;:AbstractFunctionOperator,AbstractAction}" href="#GradientRobustMultiPhysics.BilinearForm-Tuple{Type{var&quot;#s107&quot;} where var&quot;#s107&quot;&lt;:Real,Type{var&quot;#s106&quot;} where var&quot;#s106&quot;&lt;:AbstractAssemblyType,FESpace,FESpace,Type{var&quot;#s105&quot;} where var&quot;#s105&quot;&lt;:AbstractFunctionOperator,Type{var&quot;#s104&quot;} where var&quot;#s104&quot;&lt;:AbstractFunctionOperator,AbstractAction}"><code>GradientRobustMultiPhysics.BilinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function BilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE1::FESpace,
    FE2::FESpace,
    operator1::Type{&lt;:AbstractFunctionOperator},
    operator2::Type{&lt;:AbstractFunctionOperator},
    action::AbstractAction; # is only applied to FE1/operator1
    regions::Array{Int,1} = [0])</code></pre><p>Creates an unsymmetric BilinearForm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L72-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ItemIntegrator" href="#GradientRobustMultiPhysics.ItemIntegrator"><code>GradientRobustMultiPhysics.ItemIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ItemIntegrator{T&lt;:Real, AT&lt;:AbstractAssemblyType} &lt;: AbstractAssemblyPattern{T&lt;:Real,AT&lt;:AbstractAssemblyType}</code></pre><p>assembly pattern item integrator that can e.g. be used for error/norm evaluations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LinearForm" href="#GradientRobustMultiPhysics.LinearForm"><code>GradientRobustMultiPhysics.LinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LinearForm{T&lt;:Real, AT&lt;:AbstractAssemblyType} &lt;: AbstractAssemblyPattern{T&lt;:Real,AT&lt;:AbstractAssemblyType}</code></pre><p>assembly pattern linear form (that only depends on one quantity)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LinearForm-Tuple{Type{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:Real,Type{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:AbstractAssemblyType,FESpace,Type{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:AbstractFunctionOperator,AbstractAction}" href="#GradientRobustMultiPhysics.LinearForm-Tuple{Type{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:Real,Type{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:AbstractAssemblyType,FESpace,Type{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:AbstractFunctionOperator,AbstractAction}"><code>GradientRobustMultiPhysics.LinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function LinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::FESpace,
    operator::Type{&lt;:AbstractFunctionOperator},
    action::AbstractAction;
    regions::Array{Int,1} = [0])</code></pre><p>Creates a LinearForm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L34-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.MultilinearForm" href="#GradientRobustMultiPhysics.MultilinearForm"><code>GradientRobustMultiPhysics.MultilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MultilinearForm{T&lt;:Real, AT&lt;:AbstractAssemblyType} &lt;: AbstractAssemblyPattern{T&lt;:Real,AT&lt;:AbstractAssemblyType}</code></pre><p>assembly pattern multi-linear form (that depends on arbitrary many quantities)</p><p>currently this can be only assembled into a FEVector (with one free argument, all others fixed)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.MultilinearForm-Tuple{Type{var&quot;#s131&quot;} where var&quot;#s131&quot;&lt;:Real,Type{var&quot;#s130&quot;} where var&quot;#s130&quot;&lt;:AbstractAssemblyType,Array{FESpace,1},Array{DataType,1},AbstractAction}" href="#GradientRobustMultiPhysics.MultilinearForm-Tuple{Type{var&quot;#s131&quot;} where var&quot;#s131&quot;&lt;:Real,Type{var&quot;#s130&quot;} where var&quot;#s130&quot;&lt;:AbstractAssemblyType,Array{FESpace,1},Array{DataType,1},AbstractAction}"><code>GradientRobustMultiPhysics.MultilinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function MultilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a MultilinearForm that can be only assembled into a vector (with all but one fixed arguments).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L240-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NonlinearForm" href="#GradientRobustMultiPhysics.NonlinearForm"><code>GradientRobustMultiPhysics.NonlinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NonlinearForm{T&lt;:Real, AT&lt;:AbstractAssemblyType} &lt;: AbstractAssemblyPattern{T&lt;:Real,AT&lt;:AbstractAssemblyType}</code></pre><p>assembly pattern nonlinear form with two arguments (ansatz and testfunction) where te first argument can depend on more than one operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NonlinearForm-Tuple{Type{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:Real,Type{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:AbstractAssemblyType,Array{FESpace,1},FESpace,Array{DataType,1},Type{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:AbstractFunctionOperator,AbstractAction}" href="#GradientRobustMultiPhysics.NonlinearForm-Tuple{Type{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:Real,Type{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:AbstractAssemblyType,Array{FESpace,1},FESpace,Array{DataType,1},Type{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:AbstractFunctionOperator,AbstractAction}"><code>GradientRobustMultiPhysics.NonlinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function NonlinearForm(
    T::Type{&lt;:Real},
    FE1::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function
    FE2::FESpace,                   # finite element space for testfunction
    operator1::Array{DataType,1},   # operators that should be evaluated for the ansatz function
    operator2::Type{&lt;:AbstractFunctionOperator},   # operator that is evaluated for the test function
    action::AbstractAction;        # is applied to all operators of ansatz functions (to allow for Newton)
                                   # in Newton mode also the evaluation of all operators in current solution are
                                   # passed to the action
    ADnewton::Bool = false,        # perform AD to obtain additional Newton terms
    regions::Array{Int,1} = [0])</code></pre><p>Creates a NonlinearForm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L120-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.TrilinearForm" href="#GradientRobustMultiPhysics.TrilinearForm"><code>GradientRobustMultiPhysics.TrilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TrilinearForm{T&lt;:Real, AT&lt;:AbstractAssemblyType} &lt;: AbstractAssemblyPattern{T&lt;:Real,AT&lt;:AbstractAssemblyType}</code></pre><p>assembly pattern trilinear form (that depends on three quantities)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.TrilinearForm-Tuple{Type{var&quot;#s104&quot;} where var&quot;#s104&quot;&lt;:Real,Type{var&quot;#s75&quot;} where var&quot;#s75&quot;&lt;:AbstractAssemblyType,FESpace,FESpace,FESpace,Type{var&quot;#s66&quot;} where var&quot;#s66&quot;&lt;:AbstractFunctionOperator,Type{var&quot;#s65&quot;} where var&quot;#s65&quot;&lt;:AbstractFunctionOperator,Type{var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:AbstractFunctionOperator,AbstractAction}" href="#GradientRobustMultiPhysics.TrilinearForm-Tuple{Type{var&quot;#s104&quot;} where var&quot;#s104&quot;&lt;:Real,Type{var&quot;#s75&quot;} where var&quot;#s75&quot;&lt;:AbstractAssemblyType,FESpace,FESpace,FESpace,Type{var&quot;#s66&quot;} where var&quot;#s66&quot;&lt;:AbstractFunctionOperator,Type{var&quot;#s65&quot;} where var&quot;#s65&quot;&lt;:AbstractFunctionOperator,Type{var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:AbstractFunctionOperator,AbstractAction}"><code>GradientRobustMultiPhysics.TrilinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function TrilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE1::FESpace,
    FE2::FESpace,
    FE3::FESpace,
    operator1::Type{&lt;:AbstractFunctionOperator},
    operator2::Type{&lt;:AbstractFunctionOperator},
    operator3::Type{&lt;:AbstractFunctionOperator},
    action::AbstractAction; # is only applied to FE1/operator1 + FE2/operator2
    regions::Array{Int,1} = [0])</code></pre><p>Creates a TrilinearForm that can be assembeld into a matrix (with one argument fixed) or into a vector (with two fixed arguments).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L193-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.L2ErrorIntegrator-Tuple{Type{var&quot;#s130&quot;} where var&quot;#s130&quot;&lt;:Real,UserData{AbstractDataFunction},Type{var&quot;#s129&quot;} where var&quot;#s129&quot;&lt;:AbstractFunctionOperator}" href="#GradientRobustMultiPhysics.L2ErrorIntegrator-Tuple{Type{var&quot;#s130&quot;} where var&quot;#s130&quot;&lt;:Real,UserData{AbstractDataFunction},Type{var&quot;#s129&quot;} where var&quot;#s129&quot;&lt;:AbstractFunctionOperator}"><code>GradientRobustMultiPhysics.L2ErrorIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function L2ErrorIntegrator(
    T::Type{&lt;:Real},
    compare_data::UserData{AbstractDataFunction},
    operator::Type{&lt;:AbstractFunctionOperator};
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    time = 0)</code></pre><p>Creates an ItemIntegrator that compares FEVectorBlock operator-evaluations against the given compare_data and returns the L2-error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L2231-L2242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.SymmetricBilinearForm-Tuple{Type{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:Real,Type{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:AbstractAssemblyType,FESpace,Type{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:AbstractFunctionOperator,AbstractAction}" href="#GradientRobustMultiPhysics.SymmetricBilinearForm-Tuple{Type{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:Real,Type{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:AbstractAssemblyType,FESpace,Type{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:AbstractFunctionOperator,AbstractAction}"><code>GradientRobustMultiPhysics.SymmetricBilinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function SymmetricBilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE1::FESpace,
    operator1::Type{&lt;:AbstractFunctionOperator},
    action::AbstractAction; # is only applied to FE1/operator1
    regions::Array{Int,1} = [0])</code></pre><p>Creates a symmetric BilinearForm that can be assembled into a matrix or a vector (with one argument fixed)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L153-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,Array{AbstractArray{T,1} where T,1},MultilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,Array{AbstractArray{T,1} where T,1},MultilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(
    assemble!(
    b::AbstractVector,
    FE::Array{&lt;:FEVectorBlock,1},
    MLF::MultilinearForm{T, AT};
    verbosity::Int = 0,
    factor = 1)</code></pre><p>Assembly of a MultilinearForm MLF into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L1607-L1620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,FEVectorBlock,FEVectorBlock,TrilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,FEVectorBlock,FEVectorBlock,TrilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(
    assemble!(
    b::AbstractVector,
    FE1::FEVectorBlock,
    FE2::FEVectorBlock.
    TLF::TrilinearForm{T, AT};
    verbosity::Int = 0,
    factor = 1)</code></pre><p>Assembly of a TrilinearForm TLF into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L1417-L1431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,NonlinearForm{T,AT},Array{var&quot;#s66&quot;,1} where var&quot;#s66&quot;&lt;:FEVectorBlock}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,NonlinearForm{T,AT},Array{var&quot;#s66&quot;,1} where var&quot;#s66&quot;&lt;:FEVectorBlock}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(
    b::AbstractVector,
    NLF::NonlinearForm{T, AT},
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients for each operator
    verbosity::Int = 0,
    factor = 1,
    transposed_assembly::Bool = false</code></pre><p>Assembly of a NonlinearForm NLF into given AbstractVector (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L2028-L2040">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1},BilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1},BilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(
    b::AbstractArray{T,1},
    fixedFE::FEVectorBlock,    # coefficient for fixed 2nd component
    BLF::BilinearForm{T, AT};
    apply_action_to::Int = 1,
    fixed_argument::Int = 2,
    factor = 1,
    verbosity::Int = 0) where {T&lt;: Real, AT &lt;: AbstractAssemblyType}</code></pre><p>Assembly of a BilinearForm BLF into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed (default) by the given coefficients in fixedFE. With apply<em>action</em>to=2 the action can be also applied to the second argument instead of the first one (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L1014-L1029">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,2},BilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,2},BilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(
    A::AbstractArray{T,2},
    BLF::BilinearForm{T, AT};
    apply_action_to::Int = 1,
    verbosity::Int = 0,
    factor = 1,
    transposed_assembly::Bool = false,
    transpose_copy = Nothing) where {T&lt;: Real, AT &lt;: AbstractAssemblyType}</code></pre><p>Assembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L759-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,2},FEVectorBlock,TrilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,2},FEVectorBlock,TrilinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(
    assemble!(
    A::AbstractArray{T,2},
    FE1::FEVectorBlock,
    TLF::TrilinearForm{T, AT};
    verbosity::Int = 0,
    fixed_argument::Int = 1,
    transposed_assembly::Bool = false,
    factor = 1)</code></pre><p>Assembly of a TrilinearForm TLF into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, the first argument is fixed by the given coefficients in FE1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L1212-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,2},NonlinearForm{T,AT},Array{var&quot;#s60&quot;,1} where var&quot;#s60&quot;&lt;:FEVectorBlock}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,2},NonlinearForm{T,AT},Array{var&quot;#s60&quot;,1} where var&quot;#s60&quot;&lt;:FEVectorBlock}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(
    A::AbstractArray{T,2},
    NLF::NonlinearForm{T, AT},
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients for each operator
    verbosity::Int = 0,
    factor = 1,
    transposed_assembly::Bool = false</code></pre><p>Assembly of a NonlinearForm NLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L1786-L1798">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}},LinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}},LinearForm{T,AT}}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(
    b::Union{AbstractArray{T,1},AbstractArray{T,2}},
    LF::LinearForm{T,AT};
    verbosity::Int = 0) where {T&lt;: Real, AT &lt;: AbstractAssemblyType}
</code></pre><p>Assembly of a LinearForm LF into given one- or two-dimensional Array b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L625-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,2},ItemIntegrator{T,AT},Array{var&quot;#s75&quot;,1} where var&quot;#s75&quot;&lt;:FEVectorBlock}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.evaluate!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,2},ItemIntegrator{T,AT},Array{var&quot;#s75&quot;,1} where var&quot;#s75&quot;&lt;:FEVectorBlock}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.evaluate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function evaluate!(
    b::AbstractArray{T,2},
    form::ItemIntegrator{T,AT},
    FEB::FEVectorBlock;
    verbosity::Int = 0) where {T&lt;: Real, AT &lt;: AbstractAssemblyType}</code></pre><p>Evaluation of an ItemIntegrator form with given FEVectorBlock FEB into given two-dimensional Array b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L460-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate-Union{Tuple{AT}, Tuple{T}, Tuple{ItemIntegrator{T,AT},Any}} where AT&lt;:AbstractAssemblyType where T&lt;:Real" href="#GradientRobustMultiPhysics.evaluate-Union{Tuple{AT}, Tuple{T}, Tuple{ItemIntegrator{T,AT},Any}} where AT&lt;:AbstractAssemblyType where T&lt;:Real"><code>GradientRobustMultiPhysics.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function evaluate(
    form::ItemIntegrator{T,AT},
    FEB::FEVectorBlock;
    verbosity::Int = 0) where {T&lt;: Real, AT &lt;: AbstractAssemblyType}
</code></pre><p>Evaluation of an ItemIntegrator form with given FEVectorBlock FEB, only returns accumulation over all items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/743489230ab9e462c0e3d087b4920f966fb71b6c/src/assemblypatterns.jl#L590-L600">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../userdata/">« User Data</a><a class="docs-footer-nextpage" href="../meshing/">Meshing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 February 2021 13:01">Thursday 4 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
