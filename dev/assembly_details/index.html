<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assembly Details · GradientRobustMultiPhysics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GradientRobustMultiPhysics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">FE Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">FE Interpolation</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li><li><a class="tocitem" href="../pdesolvers/">PDE Solvers</a></li><li><a class="tocitem" href="../userdata/">User Data</a></li><li class="is-active"><a class="tocitem" href>Assembly Details</a><ul class="internal"><li><a class="tocitem" href="#Assembly-Types"><span>Assembly Types</span></a></li><li><a class="tocitem" href="#Assembly-Patterns"><span>Assembly Patterns</span></a></li></ul></li><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li><a class="tocitem" href="../viewers/">Export/Viewers</a></li><li><span class="tocitem">Examples (Intro)</span><ul><li><a class="tocitem" href="../examples_intro/">How to run the examples</a></li><li><a class="tocitem" href="../examples/doc_1d_bestapprox/">1D L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_bestapprox_curlpreserve/">2D Curl-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_commutinginterpolators/">Commuting Interpolators (2D)</a></li><li><a class="tocitem" href="../examples/doc_2d_convectiondiffusion/">2D Convection-Diffusion-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_cookmembrane/">2D Linear Elasticity</a></li><li><a class="tocitem" href="../examples/doc_2d_fe_on_faces/">2D Finite Elements on Faces</a></li><li><a class="tocitem" href="../examples/doc_2d_flowtransport/">2D Flow + Transport</a></li><li><a class="tocitem" href="../examples/doc_2d_liddrivencavity_anderson/">2D Lid-driven cavity (Anderson-Iteration)</a></li><li><a class="tocitem" href="../examples/doc_2d_lshape_adaptivity/">2D Adaptive Mesh Refinement (L-shape)</a></li><li><a class="tocitem" href="../examples/doc_2d_nonlin_poisson/">2D Nonlinear Poisson-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_stokes_probust/">2D Pressure-robustness</a></li><li><a class="tocitem" href="../examples/doc_2d_transientstokes/">2D Transient Stokes-Problem</a></li><li><a class="tocitem" href="../examples/doc_3d_bestapprox_divpreserve/">3D Divergence-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_3d_commutinginterpolators/">Commuting Interpolators (3D)</a></li><li><a class="tocitem" href="../examples/doc_3d_poisson/">3D Poisson-Problem</a></li><li><a class="tocitem" href="../examples/doc_rational_massmatrix/">Rational Mass Matrix</a></li></ul></li><li><span class="tocitem">Examples (Advanced)</span><ul><li><a class="tocitem" href="../examples_advanced/doc_2d_compressiblestokes/">2D Compressible Stokes</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_lshape_adaptivity_eq/">2D Equilibration Error Estimation (Global)</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_lshape_adaptivity_loceq/">2D Equilibration Error Estimation (Local)</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_nonlin_diffeq/">2D Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_other_linsolver/">2D User-defined Linear Solvers</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_stokes_hdiv-dg/">2D DG-Hdiv discretisation for Stokes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Assembly Details</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assembly Details</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/assembly_details.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assembly-Details"><a class="docs-heading-anchor" href="#Assembly-Details">Assembly Details</a><a id="Assembly-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Details" title="Permalink"></a></h1><p>The assembly of an operator is essentially based on a combination of <a href="#Assembly-Types">Assembly Types</a> and <a href="#Assembly-Patterns">Assembly Patterns</a>. The assembly type mainly allows to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.</p><h2 id="Assembly-Types"><a class="docs-heading-anchor" href="#Assembly-Types">Assembly Types</a><a id="Assembly-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Types" title="Permalink"></a></h2><p>The following assembly types are available.</p><table><tr><th style="text-align: left">AssemblyType</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">ON_CELLS</td><td style="text-align: left">assembles over the cells of the mesh</td></tr><tr><td style="text-align: left">ON_FACES</td><td style="text-align: left">assembles over all faces of the mesh</td></tr><tr><td style="text-align: left">ON_IFACES</td><td style="text-align: left">assembles over the interior faces of the mesh</td></tr><tr><td style="text-align: left">ON_BFACES</td><td style="text-align: left">assembles over the boundary faces of the mesh</td></tr><tr><td style="text-align: left">ON_EDGES (*)</td><td style="text-align: left">assembles over all edges of the mesh (in 3D)</td></tr><tr><td style="text-align: left">ON_BEDGES (*)</td><td style="text-align: left">assembles over the boundary edges of the mesh (in 3D)</td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>(*) = only reasonable in 3D and still experimental, might have some issues</p></div></div><h2 id="Assembly-Patterns"><a class="docs-heading-anchor" href="#Assembly-Patterns">Assembly Patterns</a><a id="Assembly-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Patterns" title="Permalink"></a></h2><p>Each Pattern comes with a number of arguments/quantities with associated <a href="../functionoperators/#Function-Operators">Function Operators</a> as well as one of the <a href="#Assembly-Types">Assembly Types</a> that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Important note: this assembly type is relative to the grid of the first argument of the pattern. If this argument already lives ON<em>FACES and the pattern is also ON</em>FACES, it will ultimatively assemble on the faces of the faces (that are the edges of the grid with these faces). Moreover, patterns can have <a href="@ref">Abstract Actions</a> that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has usually on to three implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed) or evaluates the pattern in the given FEVectorBlocks.</p><p>The patterns are used by the assembly of the PDE operators defined in a <a href="../pdedescription/#PDE-Description">PDE Description</a>. However, it is also possible for the user to use them directly, see e.g. the example <a href="../examples/doc_2d_commutinginterpolators/#Commuting-Interpolators-(2D)">Commuting Interpolators (2D)</a>.</p><p>The following table lists all available assembly patterns and how they can be used for assembly or evaluations.</p><table><tr><th style="text-align: center">AssemblyPattern</th><th style="text-align: center">evaluate</th><th style="text-align: center">assemble into matrix</th><th style="text-align: center">assembled into vector</th></tr><tr><td style="text-align: center">ItemIntegrator</td><td style="text-align: center">yes</td><td style="text-align: center">no</td><td style="text-align: center">no</td></tr><tr><td style="text-align: center">LinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: center">BilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes</td><td style="text-align: center">yes (1)</td></tr><tr><td style="text-align: center">TrilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (1)</td><td style="text-align: center">yes (2)</td></tr><tr><td style="text-align: center">MultilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes (N-1)</td></tr><tr><td style="text-align: center">NonlinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (L)</td><td style="text-align: center">yes (L)</td></tr></table><p>Number in brackets denotes the number of fixed arguments needed for this assembly, (L) means that a current solution is needed to evaluate (to evaluate the linearisation of the nonlinear form in this state). Evaluations of the other AssemblyPatterns will be possible in a future update, but currently have to be performed by maintaining a duplicate of the pattern rewritten as an ItemIntegrator.</p><h4 id="ItemIntegrator"><a class="docs-heading-anchor" href="#ItemIntegrator">ItemIntegrator</a><a id="ItemIntegrator-1"></a><a class="docs-heading-anchor-permalink" href="#ItemIntegrator" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ItemIntegrator" href="#GradientRobustMultiPhysics.ItemIntegrator"><code>GradientRobustMultiPhysics.ItemIntegrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function ItemIntegrator(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates an ItemIntegrator assembly pattern with the given operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/itemintegrator.jl#L7-L18">source</a></section></article><h4 id="Linearform"><a class="docs-heading-anchor" href="#Linearform">Linearform</a><a id="Linearform-1"></a><a class="docs-heading-anchor-permalink" href="#Linearform" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LinearForm" href="#GradientRobustMultiPhysics.LinearForm"><code>GradientRobustMultiPhysics.LinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function LinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a LinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/linearform.jl#L7-L19">source</a></section></article><h4 id="Bilinearform"><a class="docs-heading-anchor" href="#Bilinearform">Bilinearform</a><a id="Bilinearform-1"></a><a class="docs-heading-anchor-permalink" href="#Bilinearform" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BilinearForm" href="#GradientRobustMultiPhysics.BilinearForm"><code>GradientRobustMultiPhysics.BilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function BilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a (unsymmetric) BilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/bilinearform.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.SymmetricBilinearForm" href="#GradientRobustMultiPhysics.SymmetricBilinearForm"><code>GradientRobustMultiPhysics.SymmetricBilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function SymmetricBilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a symmetric BilinearForm assembly pattern with the given FESpaces, operators and action etc. Symmetry is not checked automatically, but is assumed during assembly!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/bilinearform.jl#L12-L24">source</a></section></article><h4 id="Trilinearform"><a class="docs-heading-anchor" href="#Trilinearform">Trilinearform</a><a id="Trilinearform-1"></a><a class="docs-heading-anchor-permalink" href="#Trilinearform" title="Permalink"></a></h4><pre><code class="language-">TrilinearForm</code></pre><h4 id="Multilinearform"><a class="docs-heading-anchor" href="#Multilinearform">Multilinearform</a><a id="Multilinearform-1"></a><a class="docs-heading-anchor-permalink" href="#Multilinearform" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.MultilinearForm" href="#GradientRobustMultiPhysics.MultilinearForm"><code>GradientRobustMultiPhysics.MultilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function MultilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a MultilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/multilinearform.jl#L7-L19">source</a></section></article><h4 id="Nonlinearform"><a class="docs-heading-anchor" href="#Nonlinearform">Nonlinearform</a><a id="Nonlinearform-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinearform" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NonlinearForm" href="#GradientRobustMultiPhysics.NonlinearForm"><code>GradientRobustMultiPhysics.NonlinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function NonlinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function and the last one refers to the test function
    operators::Array{DataType,1},   # operators that should be evaluated for the ansatz function and the last one refers to the test function
    action::AbstractAction;         # action that shoul have an AbstractNLActionKernel
    regions::Array{Int,1} = [0])</code></pre><p>Creates a NonlinearForm assembly pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/nonlinearform.jl#L7-L18">source</a></section></article><h3 id="Evaluate!-and-Assemble!"><a class="docs-heading-anchor" href="#Evaluate!-and-Assemble!">Evaluate! &amp; Assemble!</a><a id="Evaluate!-and-Assemble!-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluate!-and-Assemble!" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate!" href="#GradientRobustMultiPhysics.evaluate!"><code>GradientRobustMultiPhysics.evaluate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function evaluate!(
    b::AbstractArray{T,2},
    AP::AssemblyPattern{APT,T,AT},
    FEB::FEVectorBlock) where {APT &lt;: APT_ItemIntegrator, T&lt;: Real, AT &lt;: AbstractAssemblyType}</code></pre><p>Evaluation of an ItemIntegrator assembly pattern with given FEVectorBlocks FEB into given two-dimensional Array b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/itemintegrator.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!" href="#GradientRobustMultiPhysics.assemble!"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assemble!(
    A::AbstractArray{T,2},
    AP::AssemblyPattern{APT,T,AT};
    apply_action_to::Int = 1,
    factor = 1,
    transposed_assembly::Bool = false,
    transpose_copy = Nothing)  where {APT &lt;: APT_BilinearForm, T &lt;: Real, AT &lt;: AbstractAssemblyType}</code></pre><p>Assembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/bilinearform.jl#L47-L59">source</a></section><section><div><pre><code class="language-none">assemble!(
    b::AbstractArray{T,1},
    fixedFE::FEVectorBlock,    # coefficient for fixed 2nd component
    AP::AssemblyPattern{APT,T,AT};
    apply_action_to::Int = 1,
    fixed_argument::Int = 2,
    factor = 1) where where {APT &lt;: APT_BilinearForm, T &lt;: Real, AT &lt;: AbstractAssemblyType}</code></pre><p>Assembly of a BilinearForm BLF into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed (default) by the given coefficients in fixedFE. With apply<em>action</em>to=2 the action can be also applied to the second argument instead of the first one (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/bilinearform.jl#L243-L257">source</a></section><section><div><pre><code class="language-none">assemble!(
    assemble!(
    A::AbstractArray{T,2},
    FE1::FEVectorBlock,
    AP::TrilinearForm{T, AT};
    fixed_argument::Int = 1,
    transposed_assembly::Bool = false,
    factor = 1)</code></pre><p>Assembly of a TrilinearForm AP into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, one argument (specified by fixed_argument) is fixed by the given coefficients in FE1. Note, that the action is (currently) always applied to the first and second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/trilinearform.jl#L31-L46">source</a></section><section><div><pre><code class="language-none">assemble!(
    assemble!(
    b::AbstractVector,
    FE1::FEVectorBlock,
    FE2::FEVectorBlock.
    AP::AssemblyPattern{APT,T,AT};
    factor = 1)</code></pre><p>Assembly of a TrilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/trilinearform.jl#L203-L216">source</a></section><section><div><pre><code class="language-none">assemble!(
    assemble!(
    b::AbstractVector,
    FE::Array{&lt;:FEVectorBlock,1},
    AP::AssemblyPattern{APT,T,AT};
    factor = 1)</code></pre><p>Assembly of a MultilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/multilinearform.jl#L33-L45">source</a></section><section><div><pre><code class="language-none">assemble!(
    A::AbstractArray{T,2},
    AP::AssemblyPattern{APT,T,AT};
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1,
    transposed_assembly::Bool = false</code></pre><p>Assembly of a NonlinearForm assembly pattern into given two-dimensional AbstractArray (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/nonlinearform.jl#L33-L44">source</a></section><section><div><pre><code class="language-none">assemble!(
    b::AbstractVector,
    AP::NonlinearForm{T, AT},
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1,
    transposed_assembly::Bool = false</code></pre><p>Assembly of a NonlinearForm AP into given AbstractVector (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2c428cde1acb38b396e1f3405aef6d5abeb70394/src/assemblypatterns/nonlinearform.jl#L213-L224">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../userdata/">« User Data</a><a class="docs-footer-nextpage" href="../meshing/">Meshing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 26 March 2021 20:12">Friday 26 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
