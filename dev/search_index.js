var documenterSearchIndex = {"docs":
[{"location":"examples/doc_2d_bestapprox_divpreserve/#D-Divergence-Preserving-L2-Bestapproximation","page":"2D Divergence-Preserving L2-Bestapproximation","title":"2D Divergence-Preserving L2-Bestapproximation","text":"","category":"section"},{"location":"examples/doc_2d_bestapprox_divpreserve/","page":"2D Divergence-Preserving L2-Bestapproximation","title":"2D Divergence-Preserving L2-Bestapproximation","text":"(source code)","category":"page"},{"location":"examples/doc_2d_bestapprox_divpreserve/","page":"2D Divergence-Preserving L2-Bestapproximation","title":"2D Divergence-Preserving L2-Bestapproximation","text":"This example computes the L2-bestapproximation of some given vector-valued function into the lowest-order Raviart-Thomas space. It also preserves the divergence of the functions in the sense that the divergence of the approximation equals the piecewise integral mean of the exact divergence. Afterwards the L2 error (also of the divergence error) is computed and the solution is plotted.","category":"page"},{"location":"examples/doc_2d_bestapprox_divpreserve/","page":"2D Divergence-Preserving L2-Bestapproximation","title":"2D Divergence-Preserving L2-Bestapproximation","text":"module Example_2DBestapproxDivpreserve\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# define some vector field that should be approximated\nfunction exact_function!(result,x)\n    result[1] = x[1]^3+x[2]^2\n    result[2] = -x[1]^2 + x[2] + 1\nend\n# define its divergence\nfunction exact_divergence!(result,x)\n    result[1] = 3*x[1]*x[1] + 1\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1, Plotter = nothing)\n\n    # generate a unit square mesh and refine\n    xgrid = simplexgrid([0.0,1.0],[0.0,1.0])\n    xgrid = uniform_refine(xgrid,4)\n\n    # setup a bestapproximation problem via a predefined prototype\n    Problem = L2BestapproximationProblem(exact_function!, 2, 2; bestapprox_boundary_regions = [1,2,3,4], bonus_quadorder = 3)\n\n    # add a new unknown (Lagrange multiplier that handles the divergence constraint)\n    # here 1 is the number of components (it is scalar-valued) and 2 is the space dimension\n    add_unknown!(Problem,1,2; unknown_name = \"Lagrange multiplier for divergence\", equation_name = \"divergence constraint\")\n    add_operator!(Problem, [1,2], LagrangeMultiplier(Divergence))\n\n    # add the right-hand side data for the constraint and inspect the defined problem\n    add_rhsdata!(Problem, 2, RhsOperator(Identity, [0], exact_divergence!, 2, 1; bonus_quadorder = 2))\n    Base.show(Problem)\n\n    # choose some (inf-sup stable) finite element types\n    #FEType = [HDIVBDM1{2}, L2P0{1}]\n    FEType = [HDIVRT1{2}, L2P1{1}]\n    FES = [FESpace{FEType[1]}(xgrid),FESpace{FEType[2]}(xgrid)]\n\n    # create a solution vector and solve the problem\n    Solution = FEVector{Float64}(\"L2-Bestapproximation\",FES)\n    solve!(Solution, Problem; verbosity = verbosity)\n\n    # calculate L2 error and L2 divergence error\n    L2ErrorEvaluator = L2ErrorIntegrator(exact_function!, Identity, 2, 2; bonus_quadorder = 3)\n    L2DivergenceErrorEvaluator = L2ErrorIntegrator(exact_divergence!, Divergence, 2, 1; bonus_quadorder = 2)\n    println(\"\\nL2error(Id) = $(sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\")\n    println(\"L2error(div) = $(sqrt(evaluate(L2DivergenceErrorEvaluator,Solution[1])))\")\n\n    # plot\n    GradientRobustMultiPhysics.plot(Solution, [1,1], [Identity, Divergence]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_bestapprox_divpreserve/","page":"2D Divergence-Preserving L2-Bestapproximation","title":"2D Divergence-Preserving L2-Bestapproximation","text":"","category":"page"},{"location":"examples/doc_2d_bestapprox_divpreserve/","page":"2D Divergence-Preserving L2-Bestapproximation","title":"2D Divergence-Preserving L2-Bestapproximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_1d_bestapprox/#D-L2-Bestapproximation","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"","category":"section"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"(source code)","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"This example computes the L2-bestapproximation of some given scalar-valued function into the piecewise quadratic continuous polynomials. Afterwards the L2 error is computed and the solution is plotted.","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"module Example_1DBestapprox\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# define some (vector-valued) function (to be L2-bestapproximated in this example)\n# a user-defined (time-independent) function should always have this interface\nfunction exact_function!(result,x)\n    result[1] = (x[1]-1//2)*(x[1]-9//10)*(x[1]-1//3)*(x[1]-1//10)\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 1)\n\n    # generate mesh and uniform refine twice\n    xgrid = simplexgrid([0.0,1//3,2//3,1.0])\n    xgrid = uniform_refine(xgrid,2)\n\n    # setup a bestapproximation problem via a predefined prototype\n    # and an L2ErrorEvaluator that can be used later to compute the L2 error\n    Problem = L2BestapproximationProblem(exact_function!,1, 1; bestapprox_boundary_regions = [1,2], bonus_quadorder = 4)\n    L2ErrorEvaluator = L2ErrorIntegrator(exact_function!, Identity, 1, 1; bonus_quadorder = 4)\n\n    # choose some finite element type and generate a FESpace for the grid\n    # (here it is a one-dimensional H1-conforming P2 element H1P2{1,1})\n    FEType = H1P2{1,1}\n    FES = FESpace{FEType}(xgrid)\n\n    # generate a solution vector and solve the problem\n    # (the verbosity argument that many functions have steers the talkativity,\n    #  the larger the number, the more details)\n    Solution = FEVector{Float64}(\"L2-Bestapproximation\",FES)\n    solve!(Solution, Problem; verbosity = verbosity)\n\n    # calculate the L2 error\n    L2error = sqrt(evaluate(L2ErrorEvaluator,Solution[1]))\n    println(\"\\nL2error(BestApprox) = $L2error\")\n\n    # to compare our discrete solution with a finer one, we interpolate the exact function\n    # again on some more refined mesh and also compute the L2 error on this one\n    xgrid_fine = uniform_refine(xgrid,3)\n    FES_fine = FESpace{FEType}(xgrid_fine)\n    Interpolation = FEVector{Float64}(\"fine-grid interpolation\",FES_fine)\n    interpolate!(Interpolation[1], exact_function!)\n    println(\"L2error(FineInterpol) = $(sqrt(evaluate(L2ErrorEvaluator,Interpolation[1])))\")\n\n    # evaluate/interpolate function at nodes and plot\n    if Plotter != nothing\n        nodevals = zeros(Float64,1,size(xgrid[Coordinates],2))\n        nodevalues!(nodevals,Solution[1],FES)\n        p = ExtendableGrids.plot(xgrid, nodevals[1,:]; Plotter = Plotter, label = \"coarse approximation\")\n\n        nodevals_fine = zeros(Float64,1,size(xgrid_fine[Coordinates],2))\n        nodevalues!(nodevals_fine,Interpolation[1],FES_fine)\n        ExtendableGrids.plot(xgrid_fine, nodevals_fine[1,:]; Plotter = Plotter, clear = false, p = p, color = (1,0,0), label = \"fine interpolation\")\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"abstractactions/#Abstract-Actions","page":"AbstractActions","title":"Abstract Actions","text":"","category":"section"},{"location":"abstractactions/#General-concept","page":"AbstractActions","title":"General concept","text":"","category":"section"},{"location":"abstractactions/","page":"AbstractActions","title":"AbstractActions","text":"Parameters (possibly region- or item-dependent) are handle by AbstractAction types and can be assigned to Assembly Patterns. The action is applied to some input vector (usually the first argument of some assembly pattern) and then returns the modified result. Each AbstractAction implements the apply! interface","category":"page"},{"location":"abstractactions/","page":"AbstractActions","title":"AbstractActions","text":"apply!(result,input,::AbstractAction,qp::Int)","category":"page"},{"location":"abstractactions/","page":"AbstractActions","title":"AbstractActions","text":"that defines how the result vector is computed based on the input and the current quadrature point number.","category":"page"},{"location":"abstractactions/","page":"AbstractActions","title":"AbstractActions","text":"Before it is applied to any input or quadraturepoint, an update! step is performed upon entry on any item which prepares the data for the evaluation (fixing item and region numbers or computing the global coordinates of the quadrature points). Details of that are hidden here, since it is usually not necessary for the user to interfere with that.","category":"page"},{"location":"abstractactions/","page":"AbstractActions","title":"AbstractActions","text":"Below is a table with implemented action types and some short description what it can be used for. Click on the action name for more details.","category":"page"},{"location":"abstractactions/","page":"AbstractActions","title":"AbstractActions","text":"Action type What it does\nDoNotChangeAction does nothing  (result = input)\nMultiplyScalarAction multiplies argument (vector) with a scalar\nRegionWiseMultiplyScalarAction multiplies argument (vector) with a scalar that depends on the region\nMultiplyVectorAction multiplies argument (vector) componentwise with a vector of same length\nRegionWiseMultiplyVectorAction multiplies argument (vector) componentwise with a region-depending vector of same length\nMultiplyMatrixAction matrix-vector multiplication, input is multiplied with the specified matrix\nFunctionAction f!(result, input) for some user-specified function with this interface\nXFunctionAction f!(result, input, x) for some user-specified function (that also depends on x)\nItemWiseXFunctionAction f!(result, input, x, item) for some user-specified function (that also depends on x and item number)\nRegionWiseXFunctionAction f!(result, input, x, region) for some user-specified function (that also depends on x and region id)","category":"page"},{"location":"abstractactions/","page":"AbstractActions","title":"AbstractActions","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"actions.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"abstractactions/#GradientRobustMultiPhysics.DoNotChangeAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.DoNotChangeAction","text":"struct DoNotChangeAction <: AbstractAction\n\naction that does nothing to the input, i.e.\n\nresult[j] = input[j]\n\n(for j = 1 : argsizes[1])\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.DoNotChangeAction-Tuple{Int64}","page":"AbstractActions","title":"GradientRobustMultiPhysics.DoNotChangeAction","text":"function DoNotChangeAction(ncomponents::Int)\n\ncreates DoNotChangeAction with specified argsizes = (ncomponents, ncomponents).\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.FunctionAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.FunctionAction","text":"struct FunctionAction{T<:Real} <: AbstractAction\n\naction that puts input into the specified function f! and returns its result. The function f! should have the interface\n\nf!(result,input)\n\nand result is expected to be of length argsizes[1], input of length argsizes[2].\n\nThe quadrature order of assemblies that involve this action can be altered with bonus_quadorder.\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.FunctionAction-Tuple{Function,Array{Int64,1}}","page":"AbstractActions","title":"GradientRobustMultiPhysics.FunctionAction","text":"function FunctionAction(f!::Function, argsizes::Array{Int,1}; bonus_quadorder::Int = 0)\n\ncreates FunctionAction.\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.ItemWiseFunctionAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.ItemWiseFunctionAction","text":"mutable struct ItemWiseFunctionAction{T<:Real} <: AbstractAction\n\naction that puts input into the specified function f! and returns its result. The function f! should have the interface\n\nf!(result,input,item)\n\nand result is expected to be of length argsizes[1], input of length argsizes[2].\n\nThe quadrature order of assemblies that involve this action can be altered with bonus_quadorder.\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.ItemWiseFunctionAction-Tuple{Function,Array{Int64,1}}","page":"AbstractActions","title":"GradientRobustMultiPhysics.ItemWiseFunctionAction","text":"function ItemWiseFunctionAction(f!::Function, argsizes::Array{Int,1}; bonus_quadorder::Int = 0)\n\ncreates ItemWiseFunctionAction.\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.ItemWiseMultiplyScalarAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.ItemWiseMultiplyScalarAction","text":"mutable struct ItemWiseMultiplyScalarAction{T<:Real} <: AbstractAction\n\naction that multiplies an item-dependent scalar to the input, i.e.\n\nresult[j] = input[j] * value[item]\n\n(for j = 1 : argsizes[1])\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.ItemWiseMultiplyScalarAction-Tuple{AbstractArray{var\"#s361\",1} where var\"#s361\"<:Real,Array{Int64,1}}","page":"AbstractActions","title":"GradientRobustMultiPhysics.ItemWiseMultiplyScalarAction","text":"function ItemWiseMultiplyScalarAction(value4item::Array{<:Real,1}, argsizes::Array{Int,1})\n\ncreates ItemWiseMultiplyScalarAction with specified argsizes = (length(result), length(input)).\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.ItemWiseXFunctionAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.ItemWiseXFunctionAction","text":"mutable struct ItemWiseXFunctionAction{T<:Real} <: AbstractAction\n\naction that puts input into the specified function f! and returns its result. The function f! should have the interface\n\nf!(result,input,x,item)\n\nand result is expected to be of length argsizes[1], input of length argsizes[2].\n\nThe quadrature order of assemblies that involve this action can be altered with bonus_quadorder.\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.ItemWiseXFunctionAction-Tuple{Function,Array{Int64,1},Int64}","page":"AbstractActions","title":"GradientRobustMultiPhysics.ItemWiseXFunctionAction","text":"function ItemWiseXFunctionAction(f!::Function, argsizes::Array{Int,1}, xdim::Int; bonus_quadorder::Int = 0)\n\ncreates ItemWiseXFunctionAction.\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.MultiplyMatrixAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.MultiplyMatrixAction","text":"struct MultiplyMatrixAction{T<:Real} <: AbstractAction\n\naction that multiplies input vector with a matrix, i.e. (note that also gradients are transferred as vectors)\n\nresult = value * input\n\n(resultdim = argsizes[1])\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.MultiplyMatrixAction-Tuple{Array{var\"#s361\",2} where var\"#s361\"<:Real,Array{Int64,1}}","page":"AbstractActions","title":"GradientRobustMultiPhysics.MultiplyMatrixAction","text":"function MultiplyMatrixAction(matrix::Array{<:Real,2}, argsizes::Array{Int,1})\n\ncreates MultiplyMatrixAction with specified argsizes = (length(result), length(input)).\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.MultiplyScalarAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.MultiplyScalarAction","text":"struct MultiplyScalarAction{T<:Real} <: AbstractAction\n\naction that multiplies a scalar to the input, i.e.\n\nresult[j] = input[j] * value\n\n(for j = 1 : argsizes[1])\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.MultiplyScalarAction-Tuple{Real,Array{Int64,1}}","page":"AbstractActions","title":"GradientRobustMultiPhysics.MultiplyScalarAction","text":"function MultiplyScalarAction(value::Real, argsizes::Array{Int,1})\n\ncreates MultiplyScalarAction with specified argsizes = (length(result), length(input)).\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.MultiplyVectorAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.MultiplyVectorAction","text":"struct MultiplyVectorAction{T<:Real} <: AbstractAction\n\naction that multiplies a different scalar to each component of the input, i.e.\n\nresult[j] = input[j] * value[j]\n\n(for j = 1 : argsizes[1])\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.MultiplyVectorAction-Tuple{AbstractArray{var\"#s361\",1} where var\"#s361\"<:Real,Array{Int64,1}}","page":"AbstractActions","title":"GradientRobustMultiPhysics.MultiplyVectorAction","text":"function MultiplyVectorAction(values::Array{<:Real,1}, argsizes::Array{Int,1})\n\ncreates MultiplyVectorAction with specified argsizes = (length(result), length(input)).\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.RegionWiseMultiplyScalarAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.RegionWiseMultiplyScalarAction","text":"struct RegionWiseMultiplyScalarAction{T<:Real} <: AbstractAction\n\naction that multiplies a region-dependent scalar to the input, i.e.\n\nresult[j] = input[j] * value[region]\n\n(for j = 1 : argsizes[1])\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.RegionWiseMultiplyScalarAction-Tuple{AbstractArray{var\"#s361\",1} where var\"#s361\"<:Real,Array{Int64,1}}","page":"AbstractActions","title":"GradientRobustMultiPhysics.RegionWiseMultiplyScalarAction","text":"function RegionWiseMultiplyScalarAction(value4region::Array{<:Real,1}, argsizes::Array{Int,1})\n\ncreates RegionWiseMultiplyScalarAction with specified argsizes = (length(result), length(input)).\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.RegionWiseMultiplyVectorAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.RegionWiseMultiplyVectorAction","text":"struct RegionWiseMultiplyVectorAction{T<:Real} <: AbstractAction\n\naction that multiplies a different region-dependent scalar to each component of the input, i.e.\n\nresult[j] = input[j] * value[region][j]\n\n(for j = 1 : argsizes[1])\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.RegionWiseMultiplyVectorAction-Tuple{Array{Array{var\"#s362\",1} where var\"#s362\"<:Real,1},Array{Int64,1}}","page":"AbstractActions","title":"GradientRobustMultiPhysics.RegionWiseMultiplyVectorAction","text":"function RegionWiseMultiplyVectorAction(values4region::Array{Array{<:Real,1},1}, argsizes::Array{Int,1})\n\ncreates RegionWiseMultiplyVectorAction with specified argsizes = (length(result), length(input)).\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.RegionWiseXFunctionAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.RegionWiseXFunctionAction","text":"mutable struct RegionWiseXFunctionAction{T<:Real} <: AbstractAction\n\naction that puts input into the specified function f! and returns its result. The function f! should have the interface\n\nf!(result,input,x,region)\n\nand result is expected to be of length argsizes[1], input of length argsizes[2].\n\nThe quadrature order of assemblies that involve this action can be altered with bonus_quadorder.\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.RegionWiseXFunctionAction-Tuple{Function,Array{Int64,1},Int64}","page":"AbstractActions","title":"GradientRobustMultiPhysics.RegionWiseXFunctionAction","text":"function RegionWiseXFunctionAction(f!::Function, argsizes::Array{Int,1}, xdim::Int; bonus_quadorder::Int = 0)\n\ncreates RegionWiseXFunctionAction.\n\n\n\n\n\n","category":"method"},{"location":"abstractactions/#GradientRobustMultiPhysics.XFunctionAction","page":"AbstractActions","title":"GradientRobustMultiPhysics.XFunctionAction","text":"struct XFunctionAction{T<:Real} <: AbstractAction\n\naction that puts input into the specified function f! and returns its result. The function f! should have the interface\n\nf!(result,input,x)\n\nand result is expected to be of length argsizes[1], input of length argsizes[2].\n\nThe quadrature order of assemblies that involve this action can be altered with bonus_quadorder.\n\n\n\n\n\n","category":"type"},{"location":"abstractactions/#GradientRobustMultiPhysics.XFunctionAction-Tuple{Function,Array{Int64,1},Int64}","page":"AbstractActions","title":"GradientRobustMultiPhysics.XFunctionAction","text":"function XFunctionAction(f!::Function, argsizes::Array{Int,1}, xdim::Int; bonus_quadorder::Int = 0)\n\ncreates XFunctionAction.\n\n\n\n\n\n","category":"method"},{"location":"viewers/#Export-and-Viewers","page":"Export/Viewers","title":"Export and Viewers","text":"","category":"section"},{"location":"viewers/","page":"Export/Viewers","title":"Export/Viewers","text":"Plotting is possible e.g. via calculation of nodal values and the plot routines from ExtendableGrids.jl. It is also possible to export (the nodal values) of a FEVector as a vtk datafile and load it into e.g. paraview.","category":"page"},{"location":"viewers/","page":"Export/Viewers","title":"Export/Viewers","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"plots.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"viewers/#GradientRobustMultiPhysics.plot-Tuple{FEVector,Array{Int64,1},Array{DataType,1}}","page":"Export/Viewers","title":"GradientRobustMultiPhysics.plot","text":"plot(Source::FEVector, blockids::Array{Int64,1}, operators::Array{DataType,1}; Plotter, use_subplots, subplots_per_column, colorlevels, isolines, aspect, show, clear, cbar, verbosity, cmap, maintitle, fsize)\n\n\nPlots operators applied to components of a given FEVector via ExtendablePlots.plot, either in subplots or several single plots.\n\n\n\n\n\n","category":"method"},{"location":"viewers/","page":"Export/Viewers","title":"Export/Viewers","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"writevtk.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"viewers/#GradientRobustMultiPhysics.writeVTK!-Tuple{String,FEVector}","page":"Export/Viewers","title":"GradientRobustMultiPhysics.writeVTK!","text":"writeVTK!(filename::String, Data::FEVector; blocks, names, vectorabs)\n\n\nWrites the specified FEVector into a vtk datafile with the given filename. Each component of each FEVectorBlock (or the subset specified by blocks) is saved separately. Vector-valued quantities also generate a data field that represents the absolute value of the vector field at each grid point.\n\n\n\n\n\n","category":"method"},{"location":"functionoperators/#Function-Operators","page":"Function Operators","title":"Function Operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"FunctionOperators are building blocks for the weak form and define the operations that should be applied to the trial and test functions (and their discrete representatives) inside some PDEOperator. Below is a list of currently available FunctionOperators. Note, that not all operators an be applied to all finite element types.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Function operator Description\nIdentity identity\nIdentityComponent{c} identity of c-th component\nIdentityDisc{Jump} jumps of identity (only over faces)\nNormalFlux normal flux (function times normal)\nGradient gradient/Jacobian\nGradientDisc{Jump} jumps of gradient/Jacobian (only over faces)\nSymmetricGradient symmetric part of the gradient\nDivergence divergence\nCurlScalar curl operator 1D to 2D (rotated gradient)\nCurl2D curl operator 2D to 1D\nReconstructionIdentity{FEType} reconstruction operator into specified FEType\nReconstructionDivergence{FEType} divergence of FEType reconstruction operator\nReconstructionGradient{FEType} gradient of FEType reconstruction operator\n ","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nEspecially note the operators Reconstruction...{FEType} operators that allow to evaluate operators of some reconstructed version of a vector-valued testfunction that maps its discrete divergence to the divergence and so allows e.g. gradient-robust discretisations with classical non divergence-conforming ansatz spaces. So far such operators are available for the vector-valued Crouzeix-Raviart and Bernardi–Raugel finite element types.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"functionoperators.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"functionoperators/#GradientRobustMultiPhysics.AbstractFunctionOperator","page":"Function Operators","title":"GradientRobustMultiPhysics.AbstractFunctionOperator","text":"abstract type AbstractFunctionOperator\n\nroot type for FunctionOperators.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.Curl2D","page":"Function Operators","title":"GradientRobustMultiPhysics.Curl2D","text":"abstract type Curl2D <: AbstractFunctionOperator\n\nevaluates the curl of some two-dimensional vector field, i.e. Curl2D((u1,u2)) = du2/dx1 - du1/dx2\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.CurlScalar","page":"Function Operators","title":"GradientRobustMultiPhysics.CurlScalar","text":"abstract type CurlScalar <: AbstractFunctionOperator\n\nevaluates the curl of some scalar function in 2D, i.e. the rotated gradient.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.Divergence","page":"Function Operators","title":"GradientRobustMultiPhysics.Divergence","text":"abstract type Divergence <: AbstractFunctionOperator\n\nevaluates the divergence of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.Gradient","page":"Function Operators","title":"GradientRobustMultiPhysics.Gradient","text":"abstract type Gradient <: AbstractFunctionOperator\n\nevaluates the gradient of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.Identity","page":"Function Operators","title":"GradientRobustMultiPhysics.Identity","text":"abstract type Identity <: AbstractFunctionOperator\n\nidentity operator: evaluates finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.IdentityComponent","page":"Function Operators","title":"GradientRobustMultiPhysics.IdentityComponent","text":"abstract type IdentityComponent <: AbstractFunctionOperator\n\nidentity operator: evaluates only the c-th component of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.IdentityDisc","page":"Function Operators","title":"GradientRobustMultiPhysics.IdentityDisc","text":"abstract type IdentityDisc <: Identity\n\nidentity jump operator: evaluates face jumps of finite element function\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.NormalFlux","page":"Function Operators","title":"GradientRobustMultiPhysics.NormalFlux","text":"abstract type NormalFlux <: AbstractFunctionOperator\n\nevaluates the normal-flux of the finite element function.\n\nonly available on FACES/BFACES and currently only for H1 and Hdiv elements\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.ReconstructionDivergence","page":"Function Operators","title":"GradientRobustMultiPhysics.ReconstructionDivergence","text":"abstract type ReconstructionDivergence <: Divergence\n\nevaluates the divergence of the reconstructed finite element function.\n\nFEreconst specifies the reconstruction space and reconstruction algorithm if it is defined for the finite element that it is applied to.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.ReconstructionGradient","page":"Function Operators","title":"GradientRobustMultiPhysics.ReconstructionGradient","text":"abstract type ReconstructionGradient <: Gradient\n\nreconstruction gradient operator: evaluates the gradient of a reconstructed version of the finite element function.\n\nFEreconst specifies the reconstruction space and reconstruction algorithm if it is defined for the finite element that it is applied to.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.ReconstructionIdentity","page":"Function Operators","title":"GradientRobustMultiPhysics.ReconstructionIdentity","text":"abstract type ReconstructionIdentity <: Identity\n\nreconstruction identity operator: evaluates a reconstructed version of the finite element function.\n\nFEreconst specifies the reconstruction space and reconstruction algorithm if it is defined for the finite element that it is applied to.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.SymmetricGradient","page":"Function Operators","title":"GradientRobustMultiPhysics.SymmetricGradient","text":"abstract type SymmetricGradient <: AbstractFunctionOperator\n\nevaluates the symmetric part of the gradient of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.TangentialGradient","page":"Function Operators","title":"GradientRobustMultiPhysics.TangentialGradient","text":"abstract type TangentialGradient <: AbstractFunctionOperator\n\nevaluates the gradient of the tangential part of some vector-valued finite element function.\n\n\n\n\n\n","category":"type"},{"location":"pdeprototypes/#PDE-Prototypes","page":"PDE Prototypes","title":"PDE Prototypes","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Below all available prototypes (i.e. pre-defined constructors for PDEDescription) are listed.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"note: Note\nFor most prototypes boundary data and right-hand side data or other modifications to the weak form of the PDE have to be added after a proto-type constructor has been called, see the examples for further assistance.","category":"page"},{"location":"pdeprototypes/#Poisson-equation","page":"PDE Prototypes","title":"Poisson equation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Poisson equation seeks a function u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"- mu Delta u = f","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is some diffusion coefficient and f some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The (primal) weak formulation (for homogeneous Dirichlet boundary data) seeks u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(mu nabla unabla v)  = (fv) quad textfor all  vin H^1_0(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"PoissonProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.PoissonProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.PoissonProblem","text":"function PoissonProblem(\n    dimension::Int = 2;\n    ncomponents::Int = 1,\n    diffusion = 1.0)\n\nCreates a PDEDescription for a Poisson problem with specified number of components and globally constant diffusion parameter.\n\nBoundary and right-hand side data or other modifications have to be added afterwards.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Example-Script: EXAMPLE_ConvectionDiffusion.jl","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Remarks:","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"dual weak formulations are also possible but are not available as a prototype currently","category":"page"},{"location":"pdeprototypes/#Incompressible-Navier–Stokes-equations","page":"PDE Prototypes","title":"Incompressible Navier–Stokes equations","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Navier–Stokes equations in d dimensions seek a (vector-valued) velocity mathbfu and a pressure p such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is some viscosity coefficient and f some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The weak formulation (for homogeneous Dirichlet boundary data) seeks (mathbfup) such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"beginaligned\n(mu nabla mathbfunabla mathbfv) + ((u cdot nabla) mathbfu mathbfv) + (mathrmdiv mathbfv p)  = (mathbffmathbfv)  textfor all  mathbfvin H^1_0(Omega)^d\n(mathrmdiv mathbfu q)  = 0  textfor all  q in L^2_0(Omega)\nendaligned","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"IncompressibleNavierStokesProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.IncompressibleNavierStokesProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.IncompressibleNavierStokesProblem","text":"function IncompressibleNavierStokesProblem(\n    dimension::Int = 2;\n    viscosity = 1.0,\n    nonlinear::Bool = true,\n    nopressureconstraint::Bool = false,\n    pmean = 0)\n\nCreates a PDEDescription for the incompressible Navier-Stokes equations of the specified dimension and globally constant viscosity parameter.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Remarks:","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"if nonlinear == false the nonlinear convection term is not added to the equation resulting in the plain Stokes equations.\nif nopressureconstraint == true removes the integral mean constraint on the pressure.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Example-Scripts: EXAMPLEStokes.jl, EXAMPLEStokes_probust.jl","category":"page"},{"location":"pdeprototypes/#Compressible-Navier–Stokes-equations","page":"PDE Prototypes","title":"Compressible Navier–Stokes equations","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The compressible Navier–Stokes equations in d dimensions seek a (vector-valued) velocity mathbfu, a density varrho and a pressure p such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"beginaligned\n- mu Delta mathbfu + lambda nabla(mathrmdiv(mathbfu))  + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff + varrho mathbfg\nmathrmdiv(varrho mathbfu)  = 0\n        p  = eos(varrho)\n        int_Omega varrho  dx  = M\n        varrho  geq 0\nendaligned","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where eos is some equation of state function that describes the dependence of the pressure on the density (and further physical quantities like temperature in a more general setting). Moreover, mu and lambda are Lame parameters and mathbff and mathbfg are given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The weak formulation (for homogeneous Dirichlet boundary data) seeks (mathbfupvarrho) such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"beginaligned\n(mu nabla mathbfunabla mathbfv) + (lambda mathrmdiv mathbfumathrmdiv mathbfv)  + ((u cdot nabla) mathbfu mathbfv) + (mathrmdiv mathbfv p)  = (mathbffmathbfv)  textfor all  mathbfv in H^1_0(Omega)^d\n(varrho mathbfu nabla q)  = 0  textfor all  q in W^1infty(Omega)\n        p  = eos(varrho)\n        int_Omega varrho  dx  = M\n        varrho  geq 0\nendaligned","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for a proper weak formulation that can be solved iteratively can be generated with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"CompressibleNavierStokesProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.CompressibleNavierStokesProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.CompressibleNavierStokesProblem","text":"function CompressibleNavierStokesProblem(\n    equation_of_state!::Function,\n    gravity!::Function,\n    dimension::Int = 2;\n    viscosity = 1.0,\n    lambda = 1.0,\n    nonlinear::Bool = true)\n\nCreates a PDEDescription for the compressible Navier-Stokes equations of the specified dimension, Lame parameters viscosity and lambda and the given equation of state function.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Example-Script: EXAMPLE_CompressibleStokes.jl","category":"page"},{"location":"pdeprototypes/#Navier-Lame-equations-(linear-elasticity)","page":"PDE Prototypes","title":"Navier-Lame equations (linear elasticity)","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Navier-Lame equations seek a displacement mathbfu such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"- mathrmdiv( mathbbC epsilon( mathbfu)) = mathbff","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where epsilon( mathbfu) is the symmetric part of the gradient, mathbbC is the stiffness tensor (according to Hooke's law) and mathbff some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"In 1D, it is assumed that the stiffness tensor has the form","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"mathbbC epsilon( u) = mu nabla u","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is the elasticity modulus. In 2D, it is assumed that the stiffness tensor has the form","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"mathbbC epsilon( u) = 2 mu epsilon( mathbfu) + lambda mathrmtr(epsilon( mathbfu))","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu and lambda are the Lame coefficients.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The (primal) weak formulation (for homogeneous Dirichlet boundary data) seeks u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(mathbbC epsilon(mathbfu)epsilon(mathbfv)) = (mathbffmathbfv) quad textfor all  vin H^1_0(Omega)^d","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"LinearElasticityProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.LinearElasticityProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.LinearElasticityProblem","text":"function LinearElasticityProblem(\n    dimension::Int = 2;\n    elasticity_modulus = 1.0,\n    shear_modulus = 1.0,\n    lambda = 1.0)\n\nCreates a PDEDescription for the linear elasticity problem of the specified dimension.\n\nIf dimension == 1, only the elasticitymodulus is used as a parameter in the Hookian stiffness operator. If dimension == 2, shearmodulus and lambda are used as Lame parameters in the Hookian stiffness operator.\n\nBoundary and right-hand side data or other modifications have to be added afterwards.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Example-Scripts: EXAMPLECookMembrane.jl, EXAMPLEElasticTire2.jl","category":"page"},{"location":"pdeprototypes/#L2-Bestapproximation","page":"PDE Prototypes","title":"L2-Bestapproximation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"This PDEDescription can be used to setup an L2-Bestapproximation very fast. The weak formulation simply seeks some function u such that, for some given function u_textexact, it holds u = u_textexact along the (specified) boundary and","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(uv) = (u_textexactv) quad textfor all  vin L^2(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Of course, on the continuous level, it holds u = u_textexact, but if the weak formulation is assembled for a finite element space one obtains a discrete L2-bestapproximation for this space.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"L2BestapproximationProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.L2BestapproximationProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.L2BestapproximationProblem","text":"function L2BestapproximationProblem(\n    uexact::Function,\n    dimension::Int = 2,\n    ncomponents::Int = 1;\n    bonus_quadorder::Int = 0,\n    bestapprox_boundary_regions = [])\n\nCreates an PDEDescription for an L2-Bestapproximation problem for the given exact function. Since this prototype already includes boundary and right-hand side data also a bonus quadrature order can be specified to steer the accuracy.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/#H1-Bestapproximation","page":"PDE Prototypes","title":"H1-Bestapproximation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"This PDEDescription can be used to setup an H1-Bestapproximation very fast. The weak formulation simply seeks some function u such that, for some given function u_textexact, it holds u = u_textexact along the (specified) boundary and","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(nabla unabla v) = (nabla u_textexact nabla v) quad textfor all  vin H^1_0(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"H1BestapproximationProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.H1BestapproximationProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.H1BestapproximationProblem","text":"function H1BestapproximationProblem(\n    exact_function_gradient::Function,\n    exact_function_boundary::Function,\n    dimension::Int = 2,\n    ncomponents::Int = 1;\n    bonus_quadorder::Int = 0,\n    bonus_quadorder_boundary::Int = 0,\n    bestapprox_boundary_regions = [])\n\nCreates an PDEDescription for an H1-Bestapproximation problem for the given exact function (only used on the boundary) and its exact gradient (used in the right-hand side). Since this prototype already includes boundary and right-hand side data also a bonus quadrature order can be specified to steer the accuracy.\n\n\n\n\n\n","category":"function"},{"location":"examples/doc_2d_compressiblestokes/#D-Compressible-Stokes","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"","category":"section"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"(source code)","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"This example solves the compressible Stokes equations where one seeks a (vector-valued) velocity mathbfu, a density varrho and a pressure p such that","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"beginaligned\n- mu Delta mathbfu + lambda nabla(mathrmdiv(mathbfu)) + nabla p  = mathbff + varrho mathbfg\nmathrmdiv(varrho mathbfu)  = 0\n        p  = eos(varrho)\n        int_Omega varrho  dx  = M\n        varrho  geq 0\nendaligned","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"Here eos eos is some equation of state function that describes the dependence of the pressure on the density (and further physical quantities like temperature in a more general setting). Moreover, mu and lambda are Lame parameters and mathbff and mathbfg are given right-hand side data.","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"In this example we solve a analytical toy problem with the prescribed solution","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"beginaligned\nmathbfu(mathbfx)  =0\nvarrho(mathbfx)  = 1 - (x_2 - 05)c\np = eos(varrho) = c varrho^gamma\nendaligned","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"such that mathbff = 0 and mathbfg nonzero to match the prescribed solution. This example is designed to study the well-balanced property of a discretisations. Note that gradient-robust discretisations (set reconstruct = true below) have a much smaller L2 velocity error (i.e. approximate the well-balanced state much better). For larger c the problem gets more incompressible which reduces the error further as then the right-hand side is a perfect gradient also when evaluated with the (now closer to a constant) discrete density. Also, on a uniform mesh the gradient-robust method is perfect!","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"reference: Reference\n\"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\nM. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\nComputer Methods in Applied Mechanics and Engineering 367 (2020),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"module Example_2DCompressibleStokes\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n\n# the equation of state\nfunction equation_of_state!(c,gamma)\n    function closure(pressure,density)\n        for j = 1 : length(density)\n            pressure[j] = c*density[j]^gamma\n        end\n    end\nend\n\n# the exact density (used for initial value of density if configured so)\nfunction exact_density!(M,c)\n    function closure(result,x)\n        result[1] = M*(1.0 - (x[2] - 0.5)/c)\n    end\nend\n\n# the exact velocity (zero!)\nfunction exact_velocity!(result,x)\n    result[1] = 0.0\n    result[2] = 0.0\nend\n\n# gravity right-hand side (just gravity but with opposite sign!)\nfunction rhs_gravity!(gamma,c)\n    function closure(result,x)\n        result[1] = 1.0 - (x[2] - 0.5)/c # = density\n        result[2] = - result[1]^(gamma-2) * gamma\n        result[1] = 0.0\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 2, Plotter = nothing, reconstruct::Bool = true, area = 2e-3)\n\n    # load mesh and refine\n    xgrid = simplexgrid(IOStream;file = \"assets/2d_grid_mountainrange.sg\")\n    xgrid = uniform_refine(xgrid,1)\n\n    # problem data\n    c = 10 # coefficient in equation of state\n    gamma = 1.4 # power in gamma law in equations of state\n    M = 1  # average mass for density\n    shear_modulus = 1e-1\n    lambda = - 1//3 * shear_modulus\n\n    # choose finite element type [velocity, density,  pressure]\n    FETypes = [H1BR{2}, L2P0{1}, L2P0{1}] # Bernardi--Raugel\n    #FETypes = [H1CR{2}, L2P0{1}, L2P0{1}] # Crouzeix--Raviart (possibly needs smaller timesteps)\n\n    # solver parametersExample_\n    timestep = shear_modulus / (2*c)\n    initial_density_bestapprox = true # otherwise we start with a constant density which also works but takes longer\n    maxTimeSteps = 1000  # termination criterion 1\n    stationarity_threshold = 1e-13/shear_modulus # stop when change is below this treshold\n\n    #####################################################################################\n    #####################################################################################\n\n    # load compressible Stokes problem prototype and assign boundary data\n    CStokesProblem = CompressibleNavierStokesProblem(equation_of_state!(c,gamma), rhs_gravity!(gamma,c), 2; shear_modulus = shear_modulus, lambda = lambda, nonlinear = false)\n    add_boundarydata!(CStokesProblem, 1,  [1,2,3,4], HomogeneousDirichletBoundary)\n\n    # error intergrators for velocity and density\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(exact_velocity!, Identity, 2, 2; bonus_quadorder = 0)\n    L2DensityErrorEvaluator = L2ErrorIntegrator(exact_density!(M,c), Identity, 2, 1; bonus_quadorder = 1)\n\n    # modify testfunction in operators\n    if reconstruct\n        TestFunctionOperatorIdentity = ReconstructionIdentity{HDIVRT0{2}} # identity operator for gradient-robust scheme\n        TestFunctionOperatorDivergence = ReconstructionDivergence{HDIVRT0{2}} # divergence operator for gradient-robust scheme\n    else # classical choices\n        TestFunctionOperatorIdentity = Identity\n        TestFunctionOperatorDivergence = Divergence\n    end\n    if lambda != 0\n        CStokesProblem.LHSOperators[1,1][2].operator1 = TestFunctionOperatorDivergence\n        CStokesProblem.LHSOperators[1,1][2].operator2 = TestFunctionOperatorDivergence\n    end\n    CStokesProblem.LHSOperators[1,2][1].operator1 = TestFunctionOperatorIdentity\n\n    # store matrix of velo-pressure and velo-gravity operator\n    # so that only a matrix-vector multiplication is needed in every iteration\n    CStokesProblem.LHSOperators[1,2][1].store_operator = true\n    CStokesProblem.LHSOperators[1,3][1].store_operator = true\n\n    # generate FESpaces and solution vector\n    FESpaceV = FESpace{FETypes[1]}(xgrid)\n    FESpacePD = FESpace{FETypes[2]}(xgrid)\n    Solution = FEVector{Float64}(\"velocity\",FESpaceV)\n    append!(Solution,\"density\",FESpacePD)\n    append!(Solution,\"pressure\",FESpacePD)\n\n    # initial values for density (bestapproximation or constant)\n    if initial_density_bestapprox\n        L2DensityBestapproximationProblem = L2BestapproximationProblem(exact_density!(M,c), 2, 1; bestapprox_boundary_regions = [], bonus_quadorder = 2)\n        InitialDensity = FEVector{Float64}(\"L2-Bestapproximation density\",FESpacePD)\n        solve!(InitialDensity, L2DensityBestapproximationProblem)\n        Solution[2][:] = InitialDensity[1][:]\n    else\n        for j = 1 : FESpacePD.ndofs\n            Solution[2][j] = M\n        end\n    end\n\n    # initial values for pressure obtained from equation of state\n    equation_of_state!(c,gamma)(Solution[3],Solution[2])\n    Minit= M * sum(Solution[2][:] .* xgrid[CellVolumes])\n\n    # generate time-dependent solver\n    # we have three equations [1] for velocity, [2] for density, [3] for pressure\n    # that are set to be iterated one after another via the subiterations argument\n    # only the density equation is made time-dependent via the timedependent_equations argument\n    # so we can reuse the other subiteration matrices in each timestep\n    TCS = TimeControlSolver(CStokesProblem, Solution, BackwardEuler; subiterations = [[1],[2],[3]], maxlureuse = [-1,1,-1], timedependent_equations = [2], verbosity = verbosity)\n    advance_until_stationarity!(TCS, timestep; maxTimeSteps = maxTimeSteps, stationarity_threshold = stationarity_threshold)\n\n    Md = sum(Solution[2][:] .* xgrid[CellVolumes])\n    @printf(\"  mass_error = %.4e - %.4e = %.4e \\n\",Minit, Md, abs(Minit-Md))\n\n    # compute L2 error for velocity and density\n    L2error = sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1]))\n    println(\"\\nL2error(Velocity) = $L2error\")\n    L2error = sqrt(evaluate(L2DensityErrorEvaluator,Solution[2]))\n    println(\"L2error(Density) = $L2error\")\n\n    # plots\n    GradientRobustMultiPhysics.plot(Solution, [1,2,3], [Identity, Identity, Identity]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\n\nend\n\nend","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"","category":"page"},{"location":"examples/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/#D-Hagen-Poiseuille-(Navier–Stokes)","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"","category":"section"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"(source code)","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"with exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"Here we solve the simple Hagen-Poiseuille flow on the two-dimensional unit square domain on a series of uniform refined meshes.","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"After that the errors of the Stokes solution, interpolations and bestapproximation into the FESpace is printed for easy comparison. (Note that second order schemes are exact in this example and that the mesh is structured.)","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"module Example_2DHagenPoiseuille\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n\n# data for Hagen-Poiseuille flow\nfunction exact_pressure!(viscosity)\n    function closure(result,x)\n        result[1] = viscosity*(-2*x[1]+1.0)\n    end\nend\nfunction exact_velocity!(result,x)\n    result[1] = x[2]*(1.0-x[2]);\n    result[2] = 0.0;\nend\nfunction exact_velocity_gradient!(result,x)\n    result[1] = 0.0\n    result[2] = (1.0-2.0*x[2]);\n    result[3] = 0.0;\n    result[4] = 0.0;\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1, Plotter = nothing, nonlinear = false)\n\n    # initial grid\n    # replace Parallelogrm2D by Triangle2D if you like\n    xgrid = uniform_refine(grid_unitsquare(Parallelogram2D));\n    initgrid = deepcopy(xgrid)\n\n    # problem parameters\n    viscosity = 1.0\n    nlevels = 6 # maximal number of refinement levels\n    barycentric_refinement = false # do not change\n\n    # choose one of these (inf-sup stable) finite element type pairs\n    #FETypes = [H1P2{2,2}, H1P1{1}] # Taylor--Hood\n    #FETypes = [H1CR{2}, L2P0{1}] # Crouzeix--Raviart\n    #FETypes = [H1MINI{2,2}, H1P1{1}] # MINI element on triangles only\n    #FETypes = [H1MINI{2,2}, H1CR{1}] # MINI element on triangles/quads\n    FETypes = [H1BR{2}, L2P0{1}] # Bernardi--Raugel\n    #FETypes = [H1P2{2,2}, L2P1{1}]; barycentric_refinement = true # Scott-Vogelius\n\n    # solver parameters for nonlinear solve\n    maxIterations = 20  # termination criterion 1 for nonlinear mode\n    maxResidual = 1e-10 # termination criterion 2 for nonlinear mode\n\n    #####################################################################################\n    #####################################################################################\n\n    # load Stokes problem prototype and assign data\n    StokesProblem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = nonlinear)\n    if nonlinear\n        # store matrix of Laplace operator for nonlinear solver\n        StokesProblem.LHSOperators[1,1][1].store_operator = true\n    end\n    add_boundarydata!(StokesProblem, 1, [1,3], HomogeneousDirichletBoundary)\n    add_boundarydata!(StokesProblem, 1, [2,4], BestapproxDirichletBoundary; data = exact_velocity!, bonus_quadorder = 2)\n    Base.show(StokesProblem)\n\n    # define bestapproximation problems\n    L2VelocityBestapproximationProblem = L2BestapproximationProblem(exact_velocity!, 2, 2; bestapprox_boundary_regions = [1,2,3,4], bonus_quadorder = 2)\n    L2PressureBestapproximationProblem = L2BestapproximationProblem(exact_pressure!(viscosity), 2, 1; bestapprox_boundary_regions = [], bonus_quadorder = 1)\n    H1VelocityBestapproximationProblem = H1BestapproximationProblem(exact_velocity_gradient!, exact_velocity!, 2, 2; bestapprox_boundary_regions = [1,2,3,4], bonus_quadorder = 1, bonus_quadorder_boundary = 2)\n\n    # define ItemIntegrators for L2/H1 error computation and arrays to store them\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(exact_velocity!, Identity, 2, 2; bonus_quadorder = 2)\n    L2PressureErrorEvaluator = L2ErrorIntegrator(exact_pressure!(viscosity), Identity, 2, 1; bonus_quadorder = 1)\n    H1VelocityErrorEvaluator = L2ErrorIntegrator(exact_velocity_gradient!, Gradient, 2, 4; bonus_quadorder = 1)\n    L2error_velocity = []; L2error_pressure = []; L2errorInterpolation_velocity = []; NDofs = []\n    L2errorInterpolation_pressure = []; L2errorBestApproximation_velocity = []; L2errorBestApproximation_pressure = []\n    H1error_velocity = []; H1errorInterpolation_velocity = []; H1errorBestApproximation_velocity = []\n\n    # loop over levels\n    for level = 1 : nlevels\n\n        # uniform mesh refinement\n        # in case of Scott-Vogelius we use barycentric refinement\n        if barycentric_refinement == true\n            xgrid = deepcopy(initgrid)\n            for ref = 1 : level - 1\n                xgrid = uniform_refine(xgrid)\n            end\n            xgrid = barycentric_refine(xgrid)\n        else\n            if (level > 1)\n                xgrid = uniform_refine(xgrid)\n            end\n        end\n\n        # generate FESpaces\n        FESpaceVelocity = FESpace{FETypes[1]}(xgrid)\n        FESpacePressure = FESpace{FETypes[2]}(xgrid)\n\n        # solve Stokes problem\n        Solution = FEVector{Float64}(\"Stokes velocity\",FESpaceVelocity)\n        append!(Solution,\"Stokes pressure\",FESpacePressure)\n        solve!(Solution, StokesProblem; verbosity = verbosity, linsolver = IterativeBigStabl_LUPC, maxlureuse = [10], maxIterations = maxIterations, maxResidual = maxResidual)\n        push!(NDofs,length(Solution.entries))\n\n        # interpolate\n        Interpolation = FEVector{Float64}(\"Interpolation velocity\",FESpaceVelocity)\n        append!(Interpolation,\"Interpolation pressure\",FESpacePressure)\n        interpolate!(Interpolation[1], exact_velocity!; bonus_quadorder = 2)\n        interpolate!(Interpolation[2], exact_pressure!(viscosity); bonus_quadorder = 1)\n\n        # solve bestapproximation problems\n        L2VelocityBestapproximation = FEVector{Float64}(\"L2-Bestapproximation velocity\",FESpaceVelocity)\n        L2PressureBestapproximation = FEVector{Float64}(\"L2-Bestapproximation pressure\",FESpacePressure)\n        H1VelocityBestapproximation = FEVector{Float64}(\"H1-Bestapproximation velocity\",FESpaceVelocity)\n        solve!(L2VelocityBestapproximation, L2VelocityBestapproximationProblem)\n        solve!(L2PressureBestapproximation, L2PressureBestapproximationProblem)\n        solve!(H1VelocityBestapproximation, H1VelocityBestapproximationProblem)\n\n        # compute L2 and H1 error\n        append!(L2error_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1])))\n        append!(L2errorInterpolation_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,Interpolation[1])))\n        append!(L2errorBestApproximation_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,L2VelocityBestapproximation[1])))\n        append!(L2error_pressure,sqrt(evaluate(L2PressureErrorEvaluator,Solution[2])))\n        append!(L2errorInterpolation_pressure,sqrt(evaluate(L2PressureErrorEvaluator,Interpolation[2])))\n        append!(L2errorBestApproximation_pressure,sqrt(evaluate(L2PressureErrorEvaluator,L2PressureBestapproximation[1])))\n        append!(H1error_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,Solution[1])))\n        append!(H1errorInterpolation_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,Interpolation[1])))\n        append!(H1errorBestApproximation_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,H1VelocityBestapproximation[1])))\n\n        # plot and ouput errors\n        if (level == nlevels)\n            println(\"\\n         |   L2ERROR   |   L2ERROR   |   L2ERROR\")\n            println(\"   NDOF  | VELO-STOKES | VELO-INTERP | VELO-L2BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e |\",L2error_velocity[j])\n                @printf(\" %.5e |\",L2errorInterpolation_velocity[j])\n                @printf(\" %.5e\\n\",L2errorBestApproximation_velocity[j])\n            end\n            println(\"\\n         |   H1ERROR   |   H1ERROR   |   H1ERROR\")\n            println(\"   NDOF  | VELO-STOKES | VELO-INTERP | VELO-H1BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e |\",H1error_velocity[j])\n                @printf(\" %.5e |\",H1errorInterpolation_velocity[j])\n                @printf(\" %.5e\\n\",H1errorBestApproximation_velocity[j])\n            end\n            println(\"\\n         |   L2ERROR   |   L2ERROR   |   L2ERROR\")\n            println(\"   NDOF  | PRES-STOKES | PRES-INTERP | PRES-L2BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e |\",L2error_pressure[j])\n                @printf(\" %.5e |\",L2errorInterpolation_pressure[j])\n                @printf(\" %.5e\\n\",L2errorBestApproximation_pressure[j])\n            end\n            println(\"\\nLEGEND\\n======\")\n            println(\"VELO-STOKES : discrete Stokes velocity solution ($(FESpaceVelocity.name))\")\n            println(\"VELO-INTERP : interpolation of exact velocity\")\n            println(\"VELO-L2BEST : L2-Bestapproximation of exact velocity (with boundary data)\")\n            println(\"VELO-H1BEST : H1-Bestapproximation of exact velocity (with boudnary data)\")\n            println(\"PRES-STOKES : discrete Stokes pressure solution ($(FESpacePressure.name))\")\n            println(\"PRES-INTERP : interpolation of exact pressure\")\n            println(\"PRES-L2BEST : L2-Bestapproximation of exact pressure (without boundary data)\")\n\n            # plot\n            GradientRobustMultiPhysics.plot(Solution, [1,2], [Identity, Identity]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\n\n        end\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"","category":"page"},{"location":"examples/doc_2d_hagenpoiseuille/","page":"2D Hagen-Poiseuille (Navier–Stokes)","title":"2D Hagen-Poiseuille (Navier–Stokes)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"assemblypatterns/#Assembly-Patterns","page":"AbstractAssemblyPatterns","title":"Assembly Patterns","text":"","category":"section"},{"location":"assemblypatterns/","page":"AbstractAssemblyPatterns","title":"AbstractAssemblyPatterns","text":"Assembly is reduced to one of the following patterns. Each Pattern comes with a number of arguments/quantities with associated AbstractFunctionOperators as well as an AbstractAssemblyType that states whether the form is evaluated over CELLS, FACES order BFACES. Moreover, patterns can have Abstract Actions that allow to make the evaluations parameter-, region- and/or function-dependent. Each Pattern then allows different types of their assembly into FEVector or FEMatrix where e.g. a subset of arguments is fixed.","category":"page"},{"location":"assemblypatterns/","page":"AbstractAssemblyPatterns","title":"AbstractAssemblyPatterns","text":"Usually the patterns are used by the assembly of a PDE Description. However, it is also possible for the user to use them directly, see e.g. the example 2D Commuting Interpolators.","category":"page"},{"location":"assemblypatterns/","page":"AbstractAssemblyPatterns","title":"AbstractAssemblyPatterns","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"assemblypatterns.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.AbstractAssemblyPattern","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.AbstractAssemblyPattern","text":"abstract type AbstractAssemblyPattern\n\nabstract type for assembly patterns\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.BilinearForm","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.BilinearForm","text":"struct BilinearForm{T<:Real, AT<:AbstractAssemblyType} <: AbstractAssemblyPattern{T<:Real,AT<:AbstractAssemblyType}\n\nassembly pattern bilinear form (that depends on two quantities)\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.BilinearForm-Tuple{Type{var\"#s162\"} where var\"#s162\"<:Real,Type{var\"#s97\"} where var\"#s97\"<:AbstractAssemblyType,FESpace,FESpace,Type{var\"#s78\"} where var\"#s78\"<:AbstractFunctionOperator,Type{var\"#s77\"} where var\"#s77\"<:AbstractFunctionOperator,AbstractAction}","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.BilinearForm","text":"function BilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    FE1::FESpace,\n    FE2::FESpace,\n    operator1::Type{<:AbstractFunctionOperator},\n    operator2::Type{<:AbstractFunctionOperator},\n    action::AbstractAction; # is only applied to FE1/operator1\n    regions::Array{Int,1} = [0])\n\nCreates an unsymmetric BilinearForm.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.ItemIntegrator","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.ItemIntegrator","text":"struct ItemIntegrator{T<:Real, AT<:AbstractAssemblyType} <: AbstractAssemblyPattern{T<:Real,AT<:AbstractAssemblyType}\n\nassembly pattern item integrator that can e.g. be used for error/norm evaluations\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.LinearForm","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.LinearForm","text":"struct LinearForm{T<:Real, AT<:AbstractAssemblyType} <: AbstractAssemblyPattern{T<:Real,AT<:AbstractAssemblyType}\n\nassembly pattern linear form (that only depends on one quantity)\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.LinearForm-Tuple{Type{var\"#s210\"} where var\"#s210\"<:Real,Type{var\"#s209\"} where var\"#s209\"<:AbstractAssemblyType,FESpace,Type{var\"#s186\"} where var\"#s186\"<:AbstractFunctionOperator,AbstractAction}","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.LinearForm","text":"function LinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    FE::FESpace,\n    operator::Type{<:AbstractFunctionOperator},\n    action::AbstractAction;\n    regions::Array{Int,1} = [0])\n\nCreates a LinearForm.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.MultilinearForm","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.MultilinearForm","text":"struct MultilinearForm{T<:Real, AT<:AbstractAssemblyType} <: AbstractAssemblyPattern{T<:Real,AT<:AbstractAssemblyType}\n\nassembly pattern multi-linear form (that depends on arbitrary many quantities)\n\ncurrently this can be only assembled into a FEVector (with one free argument, all others fixed)\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.MultilinearForm-Tuple{Type{var\"#s349\"} where var\"#s349\"<:Real,Type{var\"#s348\"} where var\"#s348\"<:AbstractAssemblyType,Array{FESpace,1},Array{DataType,1},AbstractAction}","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.MultilinearForm","text":"function MultilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a MultilinearForm that can be only assembled into a vector (with all but one fixed arguments).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.NonlinearForm","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.NonlinearForm","text":"struct NonlinearForm{T<:Real, AT<:AbstractAssemblyType} <: AbstractAssemblyPattern{T<:Real,AT<:AbstractAssemblyType}\n\nassembly pattern nonlinear form with two arguments (ansatz and testfunction) where te first argument can depend on more than one operator\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.NonlinearForm-Tuple{Type{var\"#s210\"} where var\"#s210\"<:Real,Type{var\"#s209\"} where var\"#s209\"<:AbstractAssemblyType,Array{FESpace,1},FESpace,Array{DataType,1},Type{var\"#s186\"} where var\"#s186\"<:AbstractFunctionOperator,AbstractAction}","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.NonlinearForm","text":"function NonlinearForm(\n    T::Type{<:Real},\n    FE1::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function\n    FE2::FESpace,                   # finite element space for testfunction\n    operator1::Array{DataType,1},   # operators that should be evaluated for the ansatz function\n    operator2::Type{<:AbstractFunctionOperator},   # operator that is evaluated for the test function\n    action::AbstractAction;        # is applied to all operators of ansatz functions (to allow for Newton)\n                                   # in Newton mode also the evaluation of all operators in current solution are\n                                   # passed to the action\n    ADnewton::Bool = false,        # perform AD to obtain additional Newton terms\n    regions::Array{Int,1} = [0])\n\nCreates a NonlinearForm.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.TrilinearForm","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.TrilinearForm","text":"struct TrilinearForm{T<:Real, AT<:AbstractAssemblyType} <: AbstractAssemblyPattern{T<:Real,AT<:AbstractAssemblyType}\n\nassembly pattern trilinear form (that depends on three quantities)\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.TrilinearForm-Tuple{Type{var\"#s77\"} where var\"#s77\"<:Real,Type{var\"#s76\"} where var\"#s76\"<:AbstractAssemblyType,FESpace,FESpace,FESpace,Type{var\"#s75\"} where var\"#s75\"<:AbstractFunctionOperator,Type{var\"#s74\"} where var\"#s74\"<:AbstractFunctionOperator,Type{var\"#s73\"} where var\"#s73\"<:AbstractFunctionOperator,AbstractAction}","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.TrilinearForm","text":"function TrilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    FE1::FESpace,\n    FE2::FESpace,\n    FE3::FESpace,\n    operator1::Type{<:AbstractFunctionOperator},\n    operator2::Type{<:AbstractFunctionOperator},\n    operator3::Type{<:AbstractFunctionOperator},\n    action::AbstractAction; # is only applied to FE1/operator1 + FE2/operator2\n    regions::Array{Int,1} = [0])\n\nCreates a TrilinearForm that can be assembeld into a matrix (with one argument fixed) or into a vector (with two fixed arguments).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.L2ErrorIntegrator","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.L2ErrorIntegrator","text":"function L2ErrorIntegrator(\n    exact_function::Function,\n    operator::Type{<:AbstractFunctionOperator},\n    xdim::Int,\n    ncomponents::Int = 1;\n    AT::Type{<:AbstractAssemblyType} = ON_CELLS,\n    bonus_quadorder::Int = 0)\n\nCreates an ItemIntegrator that compares FEVectorBlock operator-evaluations against the given exact_function and returns the L2-error.\n\n\n\n\n\n","category":"function"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.SymmetricBilinearForm-Tuple{Type{var\"#s210\"} where var\"#s210\"<:Real,Type{var\"#s209\"} where var\"#s209\"<:AbstractAssemblyType,FESpace,Type{var\"#s186\"} where var\"#s186\"<:AbstractFunctionOperator,AbstractAction}","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.SymmetricBilinearForm","text":"function SymmetricBilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    FE1::FESpace,\n    operator1::Type{<:AbstractFunctionOperator},\n    action::AbstractAction; # is only applied to FE1/operator1\n    regions::Array{Int,1} = [0])\n\nCreates a symmetric BilinearForm that can be assembled into a matrix or a vector (with one argument fixed)\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,Array{AbstractArray{T,1} where T,1},MultilinearForm{T,AT}}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    assemble!(\n    b::AbstractVector,\n    FE::Array{<:FEVectorBlock,1},\n    MLF::MultilinearForm{T, AT};\n    verbosity::Int = 0,\n    factor = 1)\n\nAssembly of a MultilinearForm MLF into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,FEVectorBlock,FEVectorBlock,TrilinearForm{T,AT}}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    assemble!(\n    b::AbstractArray{<:Real,1},\n    FE1::FEVectorBlock,\n    FE2::FEVectorBlock.\n    TLF::TrilinearForm{T, AT};\n    verbosity::Int = 0,\n    factor = 1)\n\nAssembly of a TrilinearForm TLF into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{T,1} where T,NonlinearForm{T,AT},Array{var\"#s74\",1} where var\"#s74\"<:FEVectorBlock}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    b::AbstractVector,\n    NLF::NonlinearForm{T, AT},\n    FEB::Array{<:FEVectorBlock,1};         # coefficients for each operator\n    verbosity::Int = 0,\n    factor = 1,\n    transposed_assembly::Bool = false\n\nAssembly of a NonlinearForm NLF into given AbstractVector (e.g. FEMatrixBlock).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{var\"#s48\",2} where var\"#s48\"<:Real,NonlinearForm{T,AT},Array{var\"#s47\",1} where var\"#s47\"<:FEVectorBlock}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    A::AbstractArray{<:Real,2},\n    NLF::NonlinearForm{T, AT},\n    FEB::Array{<:FEVectorBlock,1};         # coefficients for each operator\n    verbosity::Int = 0,\n    factor = 1,\n    transposed_assembly::Bool = false\n\nAssembly of a NonlinearForm NLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{var\"#s49\",2} where var\"#s49\"<:Real,BilinearForm{T,AT}}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    A::AbstractArray{<:Real,2},\n    BLF::BilinearForm{T, AT};\n    apply_action_to::Int = 1,\n    verbosity::Int = 0,\n    factor = 1,\n    transposed_assembly::Bool = false,\n    transpose_copy = Nothing) where {T<: Real, AT <: AbstractAssemblyType}\n\nAssembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{var\"#s70\",2} where var\"#s70\"<:Real,FEVectorBlock,TrilinearForm{T,AT}}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    assemble!(\n    A::AbstractArray{<:Real,2},\n    FE1::FEVectorBlock,\n    TLF::TrilinearForm{T, AT};\n    verbosity::Int = 0,\n    fixed_argument::Int = 1,\n    transposed_assembly::Bool = false,\n    factor = 1)\n\nAssembly of a TrilinearForm TLF into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, the first argument is fixed by the given coefficients in FE1.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:Real,AbstractArray{var\"#s73\",1} where var\"#s73\"<:Real,BilinearForm{T,AT}}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    b::AbstractArray{<:Real,1},\n    fixedFE::FEVectorBlock,    # coefficient for fixed 2nd component\n    BLF::BilinearForm{T, AT};\n    apply_action_to::Int = 1,\n    factor = 1,\n    verbosity::Int = 0) where {T<: Real, AT <: AbstractAssemblyType}\n\nAssembly of a BilinearForm BLF into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed by the given coefficients in fixedFE. With applyactionto=2 the action can be also applied to the second fixed argument instead of the first one (default).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{Union{AbstractArray{var\"#s74\",1} where var\"#s74\"<:Real, AbstractArray{var\"#s73\",2} where var\"#s73\"<:Real},LinearForm{T,AT}}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    b::AbstractArray{<:Real,2},\n    LF::LinearForm{T,AT};\n    verbosity::Int = 0) where {T<: Real, AT <: AbstractAssemblyType}\n\n\nAssembly of a LinearForm LF into given two-dimensional Array b.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.evaluate!-Union{Tuple{AT}, Tuple{T}, Tuple{AbstractArray{var\"#s73\",2} where var\"#s73\"<:Real,ItemIntegrator{T,AT},Array{var\"#s72\",1} where var\"#s72\"<:FEVectorBlock}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.evaluate!","text":"function evaluate!(\n    b::AbstractArray{<:Real,2},\n    form::ItemIntegrator{T,AT},\n    FEB::FEVectorBlock;\n    verbosity::Int = 0) where {T<: Real, AT <: AbstractAssemblyType}\n\nEvaluation of an ItemIntegrator form with given FEVectorBlock FEB into given two-dimensional Array b.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.evaluate-Union{Tuple{AT}, Tuple{T}, Tuple{ItemIntegrator{T,AT},Any}} where AT<:AbstractAssemblyType where T<:Real","page":"AbstractAssemblyPatterns","title":"GradientRobustMultiPhysics.evaluate","text":"function evaluate(\n    form::ItemIntegrator{T,AT},\n    FEB::FEVectorBlock;\n    verbosity::Int = 0) where {T<: Real, AT <: AbstractAssemblyType}\n\n\nEvaluation of an ItemIntegrator form with given FEVectorBlock FEB, only returns accumulation over all items.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Quadrature rules consist of points (coordinates of evauation points with respect to reference geometry) and weights. There are constructors for several AbstractElementGeometries (from ExtendableGrids) and different order (some have generic formulas for abitrary order), see below for a detailed list.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"quadrature.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"struct QuadratureRule{T<:Real, ET<:AbstractElementGeometry}\n\nA struct that contains the name of the quadrature rule, the reference points and the weights for the parameter-determined element geometry.\n\n\n\n\n\n","category":"type"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where ET<:AbstractElementGeometry0D where T<:Real","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry0D}\n\nConstructs 0D quadrature rule of specified order (always point evaluation).\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where ET<:AbstractElementGeometry1D where T<:Real","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry1D}\n\nConstructs 1D quadrature rule of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where ET<:Parallelepiped3D where T<:Real","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelepiped3D}\n\nConstructs quadrature rule on Parallelepiped3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where ET<:Parallelogram2D where T<:Real","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelogram2D}\n\nConstructs quadrature rule on Parallelogram2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where ET<:Tetrahedron3D where T<:Real","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Tetrahedron3D}\n\nConstructs quadrature rule on Tetrahedron3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where ET<:Triangle2D where T<:Real","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Triangle2D}\n\nConstructs quadrature rule on Triangle2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.eltype-Union{Tuple{QuadratureRule{T,ET}}, Tuple{ET}, Tuple{T}} where ET<:AbstractElementGeometry where T<:Real","page":"Quadrature","title":"Base.eltype","text":"eltype(_::QuadratureRule{T<:Real,ET<:AbstractElementGeometry}) -> Array{_A,1} where _A\n\n\nCustom eltype function for QuadratureRule{T,ET}.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.show-Tuple{IO,QuadratureRule{T,ET} where ET<:AbstractElementGeometry where T<:Real}","page":"Quadrature","title":"Base.show","text":"show(io::IO, Q::QuadratureRule{T,ET} where ET<:AbstractElementGeometry where T<:Real)\n\n\nCustom show function for QuadratureRule{T,ET} that prints some information.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.integrate!-Tuple{AbstractArray,ExtendableGrid,Type{var\"#s50\"} where var\"#s50\"<:AbstractAssemblyType,Function,Int64,Int64}","page":"Quadrature","title":"GradientRobustMultiPhysics.integrate!","text":"integrate!(integral4items::AbstractArray, grid::ExtendableGrid, AT::Type{var\"#s50\"} where var\"#s50\"<:AbstractAssemblyType, integrand!::Function, order::Int64, resultdim::Int64; verbosity, index_offset, item_dependent_integrand)\n\n\nIntegration that writes result on every item into integral4items.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.integrate-Tuple{ExtendableGrid,Type{var\"#s75\"} where var\"#s75\"<:AbstractAssemblyType,Function,Int64,Int64}","page":"Quadrature","title":"GradientRobustMultiPhysics.integrate","text":"integrate(grid::ExtendableGrid, AT::Type{var\"#s75\"} where var\"#s75\"<:AbstractAssemblyType, integrand!::Function, order::Int64, resultdim::Int64; verbosity, item_dependent_integrand) -> Union{Float64, Array{Float64,1}}\n\n\nIntegration that returns total integral.\n\n\n\n\n\n","category":"method"},{"location":"examples/doc_2d_commutinginterpolators/#D-Commuting-Interpolators","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"","category":"section"},{"location":"examples/doc_2d_commutinginterpolators/","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"(source code)","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"This example verifies a structural property of the H1 and Hdiv finite element spaces and their interpolators which is","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"mathrmCurl(I_mathrmP_kpsi) = I_mathrmRT_k-1(mathrmCurl(psi))","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"for the H_1 interpolator I_mathrmP_k and the standard Raviart-Thomas interpolator I_mathrmRT_k-1 for k  0. In this example we verify this identity for k=1 and k=2. Note, that the H_1 interpolator only does nodal interpolations at the vertices but not in the additional edgrees of freedom. For e.g. k=2 the interpolator preserves the moments along the edges.","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"note: Note\nIn 3D a similar commuting property holds that involves the Nedelec finite element spaces, that will be tested once there are implemented. Also the identities for k  2 will be tested once all functionality is available.","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"module Example_2DCommutingInterpolators\nusing GradientRobustMultiPhysics\n\n# define some function\nfunction exact_function!(result,x)\n    result[1] = x[1]^2-x[2]^4 + 1\nend\n# and its CurlScalar = (-dy,dx)\nfunction exact_curl!(result,x)\n    result[1] = 4*x[2]^3\n    result[2] = 2*x[1]\nend\n\n# everything is wrapped in a main function\nfunction main(;order::Int = 2)\n\n    # choose some grid\n    xgrid = uniform_refine(reference_domain(Triangle2D),2)\n\n    # choose commuting interpolators pair\n    if order == 1\n        FE = [H1P1{1},HDIVRT0{2}]; testFE = L2P0{2}\n    elseif order == 2\n        FE = [H1P2{1,2},HDIVRT1{2}]; testFE = L2P1{2}\n    end\n\n    # do the H1 interpolation of the function\n    FESH1 = FESpace{FE[1]}(xgrid)\n    H1Interpolation = FEVector{Float64}(\"H1-Interpolation\",FESH1)\n    interpolate!(H1Interpolation[1], exact_function!; bonus_quadorder = 4)\n\n    # do the Hdiv interpolation of the Curl of the function\n    # since integrals over faces have to be computed exactly we need to tune the quadrature order\n    FESHdiv = FESpace{FE[2]}(xgrid)\n    HdivCurlInterpolation = FEVector{Float64}(\"Hdiv-Interpolation\",FESHdiv)\n    interpolate!(HdivCurlInterpolation[1], exact_curl!; bonus_quadorder = 3)\n\n    # Checking the identity:\n    # Both sides of the identity are finite element function of FEtype testFE\n    # Hence, we evaluate the error by testing the identity by all basisfunctions of this type\n\n    # first: generate the test space and some matching FEVector\n    FEStest = FESpace{testFE}(xgrid)\n    error = FEVector{Float64}(\"ErrorVector\",FEStest)\n\n    # Define bilinear forms that represents testing each side of the identity with the testspace functions\n    BLF1 = BilinearForm(Float64, ON_CELLS, FEStest, FESHdiv, Identity, Identity, DoNotChangeAction(2))\n    BLF2 = BilinearForm(Float64, ON_CELLS, FEStest, FESH1, Identity, CurlScalar, DoNotChangeAction(2))\n\n    # evaluate the bilinear forms in the respective interpolations and subtract them from each other\n    # note that in these calls always the second argument of the bilinearform is fixed by the given FEVectorBlock\n    assemble!(error[1], HdivCurlInterpolation[1], BLF1)\n    assemble!(error[1], H1Interpolation[1], BLF2; factor = -1)\n\n    # do some norm that recognizes a nonzero in the vector\n    error = sqrt(sum(error[1][:].^2, dims = 1)[1])\n    println(\"error(Curl(I_$(FE[1])(psi) - I_$(FE[2])(Curl(psi))) = $error\")\n    return error\nend\n\n# test function that is called by test unit\nfunction test()\n    error = []\n    for order in [1,2]\n        push!(error, max(main(order = order)))\n    end\n    return maximum(error)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"2D Commuting Interpolators","title":"2D Commuting Interpolators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdedescription/#PDE-Description","page":"PDE Description","title":"PDE Description","text":"","category":"section"},{"location":"pdedescription/#Purpose","page":"PDE Description","title":"Purpose","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Although a more manually low-level assembly of your problem is possible, it is advised to describe it in the form of a PDEDescription to get access to certain automated mechanisms (in particular concerning solvers). The PDEDescription has similarities with the weak form of your problem (without time derivatives that are added separately) and in general does not need any information on the discretisation at this point.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"The following flow chart summarises the assemble process that is run during the solve process. The green parts can be modified/specified by the user, the rest is handled automatically. For details on steering the solver see PDE Solvers","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"(Image: Assembly Flowchart) ","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"PDEDescription\nBase.show(io::IO, PDE::PDEDescription)","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"mutable struct PDEDescription\n    name::String\n    equation_names::Array{String,1}\n    unknown_names::Array{String,1}\n    LHS::Array{Array{AbstractPDEOperator,1},2}\n    RHS::Array{Array{AbstractPDEOperator,1},1}\n    BoundaryOperators::Array{BoundaryOperator,1}\n    GlobalConstraints::Array{AbstractGlobalConstraint,1}\nend\n\nstruct that describes a PDE system with n equations and n unknowns\n\nA PDE system is described by\n\nits name\nthe names of its equations\nthe names of its unknowns\na size n x n array of Array{AbstractPDEOperator,1} LHS that describes the left-hand sides\na length n array of Array{AbstractPDEOperator,1} RHS that describes the right-hand sides\na length n array of BoundaryOperators that describes the boundary conditions for each unknown\nan array of GlobalConstraints that describes additional global constraints\n\nA PDEDescription mainly is a set of PDEOperators arranged in a quadratic n by n matrix. Every matrix row refers to one equation and the positioning of the PDEOperators (e.g. a bilinearform) immediately sets the information which unknowns have to be used to evaluate the operator. Also  nonlinear PDEOperators are possible where extra information on the further involved uknowns have to be specified. UserData is also assigned to the PDEDescription depending on their type. Operator coefficients are assigned directly to the PDEOperators (in form of AbstractActions), right-hand side data is assigned to the right-hand side array of PDEOperators and boundary data is assigned to the BoundaryOperators of the PDEDescription. Additionaly global constraints (like a global zero integral mean) can be assigned as a GlobalConstraint.\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#Base.show-Tuple{IO,PDEDescription}","page":"PDE Description","title":"Base.show","text":"show(io::IO, PDE::PDEDescription)\n\n\nCustom show function for PDEDescription that prints the PDE systems and all assigned operators\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#Creating/Extending-a-PDEDescription","page":"PDE Description","title":"Creating/Extending a PDEDescription","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Several add...! functions allow to extend the problems at any stage. There are several prototype PDEs documented on the PDE Prototypes page that can be used as a point of departure. Below is a list of functions that allows to initialise and extend a PDEDescription.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"pdedescription.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription-2","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"PDEDescription(name::String, nunknowns::Int64, ncomponents::Array{Int64,1}) -> PDEDescription\nPDEDescription(name::String, nunknowns::Int64, ncomponents::Array{Int64,1}, dim::Int64; unknown_names, equation_names) -> PDEDescription\n\n\nCreate empty PDEDescription for a specified number of unknowns.\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription-Tuple{String}","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"PDEDescription(name::String) -> PDEDescription\n\n\nCreate empty PDEDescription with no unknowns.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_boundarydata!-Tuple{PDEDescription,Int64,Any,Type{var\"#s360\"} where var\"#s360\"<:AbstractBoundaryType}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_boundarydata!","text":"add_boundarydata!(PDE::PDEDescription, position::Int64, regions::Any, btype::Type{var\"#s360\"} where var\"#s360\"<:AbstractBoundaryType; data, bonus_quadorder) -> Union{Nothing, Bool}\n\n\nAdds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.\n\nIf timedependent == true, that data function depends also on time t and is reassembled in any advance! step of a TimeControlSolver.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_constraint!-Tuple{PDEDescription,AbstractGlobalConstraint}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_constraint!","text":"add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint) -> Array{AbstractGlobalConstraint,1}\n\n\nAdds the given global constraint to the PDEDescription.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription,Array{Int64,1},GradientRobustMultiPhysics.AbstractPDEOperatorLHS}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_operator!","text":"add_operator!(PDE::PDEDescription, position::Array{Int64,1}, O::GradientRobustMultiPhysics.AbstractPDEOperatorLHS; equation_name) -> Union{Nothing, Array{AbstractPDEOperator,1}}\n\n\nAdds the given PDEOperator to the left-hand side of the PDEDescription at the specified position.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_rhsdata!-Tuple{PDEDescription,Int64,AbstractPDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_rhsdata!","text":"add_rhsdata!(PDE::PDEDescription, position::Int64, O::AbstractPDEOperator) -> Array{AbstractPDEOperator,1}\n\n\nAdds the given PDEOperator to the right-hand side of the PDEDescription at the specified position.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_unknown!","page":"PDE Description","title":"GradientRobustMultiPhysics.add_unknown!","text":"add_unknown!(PDE::PDEDescription, ncomponents::Int64) -> Array{Array{AbstractPDEOperator,1},2}\nadd_unknown!(PDE::PDEDescription, ncomponents::Int64, dim::Int64; equation_name, unknown_name) -> Array{Array{AbstractPDEOperator,1},2}\n\n\nAdds another unknown of specified dimensions to the PDEDescription.\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#PDE-Operators","page":"PDE Description","title":"PDE Operators","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"The PDE consists of PDEOperators characterising some feature of the model (like friction, convection, exterior forces etc.), they describe the continuous weak form of the PDE. The following table lists all available operators and physics-motivated constructors for them. Click on them to find out more details.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"PDEOperator subtype Special constructors Mathematically\nAbstractBilinearForm  (mathrmA(mathrmFO_1(u))mathrmFO_2(v))\n LaplaceOperator (kappa nabla unabla v)\n ReactionOperator (alpha u v)\n ConvectionOperator (beta cdot nabla u v) (beta is function)\n HookStiffnessOperator2D (mathbbC epsilon(u)epsilon(v))\nAbstractTrilinearForm  (mathrmA(mathrmFO_1(a)mathrmFO_2(u))mathrmFO_3(v))\n ConvectionOperator (a cdot nabla u v) (a is registered unknown)\n ConvectionRotationFormOperator (a x curl(u)v) (a is registered unknown, only 2D for now)\nAbstractMultilinearForm  \nGenerateNonlinearForm  (mathrmNA(mathrmFO_1(u))mathrmFO_3(v))\nRhsOperator  (f cdot mathrmFO(v))","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Legend: mathrmFO  are placeholders for Function Operators, and mathrmA stands for a (linear) Abstract Actions (that only expects the operator value of the finite element function as an input) and mathrmNA stands for a (nonlinear) Abstract Actions (see GenerateNonlinearForm for details).","category":"page"},{"location":"pdedescription/#Linear-Operators","page":"PDE Description","title":"Linear Operators","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"AbstractBilinearForm\nAbstractTrilinearForm\nAbstractMultilinearForm\nLaplaceOperator\nReactionOperator\nConvectionOperator\nConvectionRotationFormOperator\nHookStiffnessOperator1D\nHookStiffnessOperator2D\nHookStiffnessOperator3D\nBLFeval\nTLFeval\nMLFeval\nRhsOperator","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.AbstractBilinearForm","page":"PDE Description","title":"GradientRobustMultiPhysics.AbstractBilinearForm","text":"function AbstractBilinearForm(name,\n    operator1::Type{<:AbstractFunctionOperator},\n    operator2::Type{<:AbstractFunctionOperator},\n    action::AbstractAction;\n    apply_action_to = 1,\n    regions::Array{Int,1} = [0],\n    transposed_assembly::Bool = false)\n\nabstract bilinearform operator that assembles\n\nb(u,v) = intregions action(operator1(u)) * operator2(v) if applyaction_to = 1\nb(u,v) = intregions operator1(u) * action(operator2(v)) if applyaction_to = 2\n\ncan only be applied in PDE LHS\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.AbstractTrilinearForm","page":"PDE Description","title":"GradientRobustMultiPhysics.AbstractTrilinearForm","text":"mutable struct AbstractTrilinearForm{AT<:AbstractAssemblyType} <: AbstractPDEOperatorLHS\n    name::String\n    operator1::Type{<:AbstractFunctionOperator} # operator for argument 1\n    operator2::Type{<:AbstractFunctionOperator} # operator for argument 1\n    operator3::Type{<:AbstractFunctionOperator} # operator for argument 1\n    a_from::Int     # unknown id where fixed argument takes its values from\n    a_to::Int       # position of fixed argument\n    action::AbstractAction # is applied to argument 1 and 2\n    regions::Array{Int,1}\n    transposed_assembly::Bool\nend\n\nabstract trilinearform operator that assembles\n\nc(a,u,v) = intregions action(operator1(a) * operator2(u))*operator3(v)   (if ato = 1)\nc(u,a,v) = intregions action(operator1(u) * operator2(a))*operator3(v)   (if ato = 2)\n\nwhere a_from is the id of one of the unknowns of the PDEsystem\n\ncan only be applied in PDE LHS\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.AbstractMultilinearForm","page":"PDE Description","title":"GradientRobustMultiPhysics.AbstractMultilinearForm","text":"mutable struct AbstractMultilinearForm{AT<:AbstractAssemblyType} <: AbstractPDEOperatorLHS\n    name::String\n    operators::Array{DataType,1}\n    action::AbstractAction\n    regions::Array{Int,1}\nend\n\nabstract multi-linearform with arbitrary many argument of the form\n\nm(v1,v2,...,vk) = (A(O(v1),O(v2),...,O(vk-1)),Ok(vk))\n\n(so far only intended for use as RHSOperator together with MLFeval)\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.LaplaceOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.LaplaceOperator","text":"constructor for AbstractBilinearForm that describes a(u,v) = (kappa * nabla u, nabla v) where kappa is some constant diffusion coefficient\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.ReactionOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.ReactionOperator","text":"ReactionOperator(action::AbstractAction; apply_action_to, identity_operator, regions) -> AbstractBilinearForm{ON_CELLS}\n\n\nconstructor for AbstractBilinearForm that describes a(u,v) = (A(u),v) or (u,A(v)) with some user-specified action A\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.ConvectionOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.ConvectionOperator","text":"ConvectionOperator(beta::Function, xdim::Int64, ncomponents::Int64; bonus_quadorder, testfunction_operator, regions) -> AbstractBilinearForm{ON_CELLS}\n\n\nconstructor for AbstractBilinearForm that describes a(u,v) = (beta*grad(u),v) with some user-specified function beta with the interface beta(result,x) (so it writes its result into result and returns nothing)\n\n\n\n\n\nConvectionOperator(a_from::Int64, beta_operator::Any, xdim::Int64, ncomponents::Int64; fixed_argument, testfunction_operator, regions) -> AbstractTrilinearForm{ON_CELLS}\n\n\nconstructor for AbstractBilinearForm that describes a(u,v) = (beta*grad(u),v) where beta is the id of some unknown of the PDEDescription. With fixed_argument = 2 beta and u can siwtch their places.\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.ConvectionRotationFormOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.ConvectionRotationFormOperator","text":"ConvectionRotationFormOperator(beta::Int64, beta_operator::Type{var\"#s357\"} where var\"#s357\"<:AbstractFunctionOperator, xdim::Int64, ncomponents::Int64; testfunction_operator, regions)\n\n\nconstructor for AbstractBilinearForm that describes a(u,v) = (beta x curl(u),v) where beta is the id of some unknown vector field of the PDEDescription, u and v are also vector-fields and x is the cross product (so far this is only implemented in 2D)\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.HookStiffnessOperator1D","page":"PDE Description","title":"GradientRobustMultiPhysics.HookStiffnessOperator1D","text":"HookStiffnessOperator1D(mu::Real; regions, gradient_operator) -> AbstractBilinearForm{ON_CELLS}\n\n\nconstructor for AbstractBilinearForm that describes a(u,v) = (C grad(u), grad(v)) where C is the 1D stiffness tensor C grad(u) = mu grad(u)\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.HookStiffnessOperator2D","page":"PDE Description","title":"GradientRobustMultiPhysics.HookStiffnessOperator2D","text":"HookStiffnessOperator2D(mu::Real, lambda::Real; regions, gradient_operator) -> AbstractBilinearForm{ON_CELLS}\n\n\nconstructor for AbstractBilinearForm that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda\n\nIn Voigt notation C is a 3 x 3 matrix\nC = [c11,c12,  0\n     c12,c11,  0\n       0,  0,c33]\n\nwhere c33 = shear_modulus, c12 = lambda and c11 = 2*c33 + c12\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.HookStiffnessOperator3D","page":"PDE Description","title":"GradientRobustMultiPhysics.HookStiffnessOperator3D","text":"HookStiffnessOperator3D(mu::Real, lambda::Real; regions, gradient_operator) -> AbstractBilinearForm{ON_CELLS}\n\n\nconstructor for AbstractBilinearForm that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda\n\nIn Voigt notation C is a 6 x 6 matrix\nC = [c11,c12,c12,  0,  0,  0\n     c12,c11,c12,  0,  0,  0\n     c12,c12,c11,  0,  0,  0\n       0,  0,  0,c44,  0,  0\n       0,  0,  0,  0,c44,  0\n       0,  0,  0,  0,  0,c44]   \n\nwhere c44 = shear_modulus, c12 = lambda and c11 = 2*c44 + c12\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.BLFeval","page":"PDE Description","title":"GradientRobustMultiPhysics.BLFeval","text":"struct BLFeval <: AbstractPDEOperatorRHS\n    BLF::AbstractBilinearForm\n    Data::FEVectorBlock\n    factor::Real\n    nonlinear::Bool\n    timedependent::Bool\nend\n\nevaluation of a AbstractBilinearForm BLF (multiplied by a factor) where the second argument is fixed by given FEVectorBlock Data.\n\nThe operator can be manually marked as nonlinear or time-dependent to trigger reassembly at each iteration or each timestep.\n\ncan only be applied in PDE RHS\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.TLFeval","page":"PDE Description","title":"GradientRobustMultiPhysics.TLFeval","text":"struct TLFeval <: AbstractPDEOperatorRHS\n    TLF::AbstractTrilinearForm\n    Data1::FEVectorBlock\n    Data2::FEVectorBlock\n    factor::Real\n    nonlinear::Bool\n    timedependent::Bool\nend\n\nevaluation of a AbstractTrilinearForm TLF (multiplied by a factor) where the first and second argument are fixed by given FEVectorBlocks Data1 and Data2.\n\nThe operator can be manually marked as nonlinear or time-dependent to trigger reassembly at each iteration or each timestep.\n\ncan only be applied in PDE RHS\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.MLFeval","page":"PDE Description","title":"GradientRobustMultiPhysics.MLFeval","text":"struct MLFeval <: AbstractPDEOperatorRHS\n    MLF::AbstractMultilinearForm\n    Data::Array{FEVectorBlock,1}\n    factor::Real\n    nonlinear::Bool\n    timedependent::Bool\nend\n\nevaluation of a AbstractMultilinearForm MLF (multiplied by a factor) where all but the last argument are fixed by given FEVectorBlocks in the array Data.\n\nThe operator can be manually marked as nonlinear or time-dependent to trigger reassembly at each iteration or each timestep.\n\ncan only be applied in PDE RHS\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.RhsOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.RhsOperator","text":"mutable struct RhsOperator{AT<:AbstractAssemblyType} <: AbstractPDEOperatorRHS\n    rhsfunction::Function\n    testfunction_operator::Type{<:AbstractFunctionOperator}\n    timedependent::Bool\n    regions::Array{Int,1}\n    xdim:: Int\n    ncomponents:: Int\n    bonus_quadorder:: Int\n    store_operator::Bool                    # should the vector of the operator be stored?\n    storage::AbstractArray{Float64,1}       # vector can be stored here to allow for fast reassembly in iterative settings\nend\n\nright-hand side operator\n\ncan only be applied in PDE RHS\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#Nonlinear-Operators","page":"PDE Description","title":"Nonlinear Operators","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"It is possible to assign nonlinear operators in such a way that its Jacobian can be computed by automatic differentation to setup a Newton scheme, see below for details.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"GenerateNonlinearForm","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.GenerateNonlinearForm","page":"PDE Description","title":"GradientRobustMultiPhysics.GenerateNonlinearForm","text":"function GenerateNonlinearForm(\n    name::String,\n    operator1::Array{DataType,1},\n    coeff_from::Array{Int,1},\n    operator2::Type{<:AbstractFunctionOperator},\n    action_kernel::Function,\n    argsizes::Array{Int,1},\n    dim::Int;\n    AT::Type{<:AbstractAssemblyType} = ON_CELLS,\n    ADnewton::Bool = false,\n    action_kernel_rhs = nothing,\n    regions = [0])\n\ngenerates an abstract nonlinearform operator G.  The array coeff_from stores the ids of the unknowns that should be used to evaluate the operators. The array argsizes is a vector with two entries where the first one is the length of the expected result vector and the second one is the length of the input vector.\n\nIf ADnewton == true, the specified actionkernel is automatically differentiated to assemble the Jacobian DG and setup a Newton iteration. The actionkernel has to be a function of the interface \n\nfunction name(result,input)\n\nwhere input is a vector of the operators of the solution and result is what then is multiplied with operator2 of the testfunction. Given some operator G(u), the Newton iteration reads DG u_next = DG u - G(u) which is added to the rest of the (linear) operators in the PDEDescription.\n\nIf ADnewton == false, the user is epected to prescribe a linearisation of the nonlinear operator. In this case the action_kernel has to satisfy the interface\n\nfunction name(result, input_current, input_ansatz)\n\nwhere inputcurrent is a vector of the operators of the solution and inputansatz is a vecor with the operators evaluated at one of the basis functions. If necessary, also a right-hand side action in the same format can be prescribed in actionkernelrhs.\n\nNote: this is a highly experimental feature at the moment and will possibly only work when all operators are associated with the same unknown.\n\ncan only be applied in PDE LHS\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#Global-Constraints","page":"PDE Description","title":"Global Constraints","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"GlobalConstraints are additional constraints that the user does not wish to implement as a global Lagrange multiplier because it e.g. causes a dense row in the system matrix and therefore may destroy the performance of the sparse matrix routines. Such a constraint may be a fixed integral mean. Another application are periodic boundary conditions or glued-together quantities in different regions of the grid. Here a CombineDofs constraint may help.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"globalconstraints.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.CombineDofs","page":"PDE Description","title":"GradientRobustMultiPhysics.CombineDofs","text":"struct CombineDofs <: AbstractGlobalConstraint\n\ncombines specified degrees of freedom of two unknown (can be the same), which allows to glue together different unknowns in different regions or periodic boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.FixedIntegralMean","page":"PDE Description","title":"GradientRobustMultiPhysics.FixedIntegralMean","text":"struct FixedIntegralMean <: AbstractGlobalConstraint\n\nfixes integral mean of the unknown to the specified value\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"add_constraint!","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_constraint!","page":"PDE Description","title":"GradientRobustMultiPhysics.add_constraint!","text":"add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint) -> Array{AbstractGlobalConstraint,1}\n\n\nAdds the given global constraint to the PDEDescription.\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#Dirichlet-Boundary-Data","page":"PDE Description","title":"Dirichlet Boundary Data","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"BoundaryOperators carry the boundary data for each unknown. Each regions can have a different AbstractBoundaryType and an associated data function that satisfies the interface function data!(result,x) or function data!(result,x,t) if it is also time-dependent.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"AbstractBoundaryType Subtypes causes\nDirichletBoundary  \n BestapproxDirichletBoundary computation of Dirichlet data by bestapproximation along boundary faces\n InterpolateDirichletBoundary computation of Dirichlet data by interpolation along boundary faces\n HomogeneousDirichletBoundary zero Dirichlet data on all dofs","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"BoundaryOperator\nadd_boundarydata!","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.BoundaryOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.BoundaryOperator","text":"struct BoundaryOperator <: AbstractPDEOperator\n\ncollects boundary data for a component of the system and allows to specify a AbstractBoundaryType for each boundary region so far only DirichletBoundary types (see above)\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_boundarydata!","page":"PDE Description","title":"GradientRobustMultiPhysics.add_boundarydata!","text":"add_boundarydata!(PDE::PDEDescription, position::Int64, regions::Any, btype::Type{var\"#s360\"} where var\"#s360\"<:AbstractBoundaryType; data, bonus_quadorder) -> Union{Nothing, Bool}\n\n\nAdds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.\n\nIf timedependent == true, that data function depends also on time t and is reassembled in any advance! step of a TimeControlSolver.\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#Other-Boundary-Data","page":"PDE Description","title":"Other Boundary Data","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"NeumannBoundary can be implemented as a RhsOperator with on_boundary = true","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"PeriodicBoundary can be implemented as a CombineDofs <: AbstractGlobalConstraint","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"SymmetryBoundary can be implemented by penalisation as a AbstractBilinearForm on BFaces and specified boundary regions with operator NormalFlux + MultiplyScalarAction(penalty).","category":"page"},{"location":"fespace/#Finite-Element-Spaces-and-Arrays","page":"FE Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"This page describes the structure FESpace that acts as a finite element space on a given grid. See Implemented Finite Elements for a list of available finite element types.","category":"page"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"Moreover, there are special arrays FEVector and FEMatrix that carry coefficients and discretised PDEOperators.","category":"page"},{"location":"fespace/#FESpace","page":"FE Spaces and Arrays","title":"FESpace","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"FESpace{AbstractFiniteElement}\neltype(::FESpace)\nshow(::IO, ::FESpace)","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FESpace","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FESpace","text":"mutable struct FESpace{FEType<:AbstractFiniteElement}\n\nA struct that has a finite element type as parameter and carries dofmaps (CellDofs, FaceDofs, BFaceDofs) plus additional grid information and access to arrays holding coefficients if needed.\n\n\n\n\n\n","category":"type"},{"location":"fespace/#Base.eltype-Tuple{FESpace}","page":"FE Spaces and Arrays","title":"Base.eltype","text":"eltype(_::FESpace{FEType<:AbstractFiniteElement}) -> Type{FEType} where FEType<:AbstractFiniteElement\n\n\nCustom eltype function for FESpace returns the finite element type of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Tuple{IO,FESpace}","page":"FE Spaces and Arrays","title":"Base.show","text":"show(io::IO, FES::FESpace{FEType<:AbstractFiniteElement})\n\n\nCustom show function for FESpace that prints some information and all available dofmaps.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#FEVector","page":"FE Spaces and Arrays","title":"FEVector","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"A FEVector consists of FEVectorBlocks that share a common one-dimensional arrays. Each block is associated to a FESpace and can only write into a region of the common array specified by offsets. It also acts as a one-dimensional AbstractArray itself.","category":"page"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"fevector.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"struct FEVector{T} <: AbstractArray{T,1}\n\na plain array but with an additional layer of several FEVectorBlock subdivisions each carrying coefficients for their associated FESpace\n\n\n\n\n\n","category":"type"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector-Union{Tuple{T}, Tuple{Array{String,1},Array{FESpace,1}}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"FEVector{T}(name::String, FES::Array{FESpace,1}) where T <: Real\n\nCreates FEVector that has one block for each FESpace in FES.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector-Union{Tuple{T}, Tuple{String,FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"FEVector{T}(name::String, FES::FESpace) where T <: Real\n\nCreates FEVector that has one block.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEVectorBlock","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVectorBlock","text":"struct FEVectorBlock{T} <: AbstractArray{T,1}\n\nblock of an FEVector that carries coefficients for an associated FESpace and can be assigned as an AbstractArray (getindex, setindex, size, length)\n\n\n\n\n\n","category":"type"},{"location":"fespace/#Base.append!-Union{Tuple{T}, Tuple{FEVector{T},String,FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"Base.append!","text":"append!(FEF::FEVector{T<:Real}, name::String, FES::FESpace)\n\n\nCustom append function for FEVector that adds a FEVectorBlock at the end.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.fill!-Tuple{FEVectorBlock,Any}","page":"FE Spaces and Arrays","title":"Base.fill!","text":"fill!(b::FEVectorBlock, value::Any)\n\n\nCustom fill function for FEVectorBlock (only fills the block, not the complete FEVector).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Tuple{IO,FEVector}","page":"FE Spaces and Arrays","title":"Base.show","text":"show(io::IO, FEF::FEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Tuple{FEVectorBlock,AbstractArray{var\"#s78\",1} where var\"#s78\"<:Real}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(a::FEVectorBlock, b::AbstractArray{var\"#s78\",1} where var\"#s78\"<:Real; factor)\n\n\nAdds Array b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Tuple{FEVectorBlock,FEVectorBlock}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(a::FEVectorBlock, b::FEVectorBlock; factor)\n\n\nAdds FEVectorBlock b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#FEMatrix","page":"FE Spaces and Arrays","title":"FEMatrix","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"A FEMatrix consists of FEMatrixBlocks that share a common ExtendableSparseMatrix. Each block is associated to two FESpaces and can only write into a submatrix of the common sparse matrix specified by offsets. It also acts as a two-dimensional AbstractArray itself.","category":"page"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"fematrix.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"struct FEMatrix{T} <: AbstractArray{T,1}\n\nan AbstractMatrix (e.g. an ExtendableSparseMatrix) with an additional layer of several FEMatrixBlock subdivisions each carrying coefficients for their associated pair of FESpaces\n\n\n\n\n\n","category":"type"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{T}, Tuple{String,Array{FESpace,1}}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{T}(name::String, FES::Array{FESpace,1}) where T <: Real\n\nCreates FEMatrix with blocks (FESX[i],FESY[j]) (enumerated row-wise).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{T}, Tuple{String,FESpace,FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{T}(name::String, FESX::FESpace, FESY::FESpace) where T <: Real\n\nCreates FEMatrix with one rectangular block (FESX,FESY).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{T}, Tuple{String,FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{T}(name::String, FES::FESpace) where T <: Real\n\nCreates FEMatrix with one square block (FES,FES).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrixBlock","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrixBlock","text":"struct FEMatrixBlock{T} <: AbstractArray{T,2}\n\nblock of an FEMatrix that carries coefficients for an associated pair of FESpaces and can be assigned as an two-dimensional AbstractArray (getindex, setindex, size)\n\n\n\n\n\n","category":"type"},{"location":"fespace/#Base.fill!-Tuple{FEMatrixBlock,Any}","page":"FE Spaces and Arrays","title":"Base.fill!","text":"fill!(B::FEMatrixBlock, value::Any)\n\n\nCustom fill function for FEMatrixBlock (only fills the block, not the complete FEMatrix).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Tuple{IO,FEMatrix}","page":"FE Spaces and Arrays","title":"Base.show","text":"show(io::IO, FEM::FEMatrix)\n\n\nCustom show function for FEMatrix that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Tuple{FEMatrixBlock,FEMatrixBlock}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(A::FEMatrixBlock, B::FEMatrixBlock; factor)\n\n\nAdds FEMatrixBlock B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock,ExtendableSparseMatrix{Tv,Ti}}} where Ti<:Integer where Tv","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(A::FEMatrixBlock, B::ExtendableSparseMatrix{Tv,Ti<:Integer}; factor)\n\n\nAdds ExtendableSparseMatrix B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock_matmul!-Tuple{FEVectorBlock,FEMatrixBlock,FEVectorBlock}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock_matmul!","text":"addblock_matmul!(a::FEVectorBlock, B::FEMatrixBlock, b::FEVectorBlock; factor)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock,ExtendableSparseMatrix{Tv,Ti},FEVectorBlock}} where Ti<:Integer where Tv","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock_matmul!","text":"addblock_matmul!(a::FEVectorBlock, B::ExtendableSparseMatrix{Tv,Ti<:Integer}, b::FEVectorBlock; factor)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.lrmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:Real,ExtendableSparseMatrix{Tv,Ti},AbstractArray{var\"#s73\",1} where var\"#s73\"<:Real}} where Ti<:Integer where Tv","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.lrmatmul","text":"lrmatmul(a::AbstractArray{var\"#s74\",1} where var\"#s74\"<:Real, B::ExtendableSparseMatrix{Tv,Ti<:Integer}, b::AbstractArray{var\"#s73\",1} where var\"#s73\"<:Real; factor) -> Any\n\n\nComputes vector'-matrix-vector product a'Bb.\n\n\n\n\n\n","category":"method"},{"location":"examples/doc_2d_liddrivencavity_autonewton/#D-Lid-driven-cavity-(AD-Newton)","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"","category":"section"},{"location":"examples/doc_2d_liddrivencavity_autonewton/","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"(source code)","category":"page"},{"location":"examples/doc_2d_liddrivencavity_autonewton/","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"This example solves the lid-driven cavity problem where one seeks a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/doc_2d_liddrivencavity_autonewton/","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_liddrivencavity_autonewton/","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"where mathbfu = (10) along the top boundary of a square domain.","category":"page"},{"location":"examples/doc_2d_liddrivencavity_autonewton/","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"This examples highlights the use of automatic differentation to obtain Newton derivatives of nonlinear PDEOperators.","category":"page"},{"location":"examples/doc_2d_liddrivencavity_autonewton/","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"module Example_2DLidDrivenCavityADNewton\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# data\nfunction boundary_data_top!(result,x)\n    result[1] = 1.0;\n    result[2] = 0.0;\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 2, Plotter = nothing)\n\n    # grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), 5);\n\n    # problem parameters\n    viscosity = 1e-2\n    ADnewton = true # use automatic differentation to setup Newton (otherwise hardcoded Newton terms)\n    maxIterations = 50  # termination criterion 1 for nonlinear mode\n    maxResidual = 1e-12 # termination criterion 2 for nonlinear mode\n\n    barycentric_refinement = false # do not change\n    # choose one of these (inf-sup stable) finite element type pairs\n    #FETypes = [H1P2{2,2}, H1P1{1}] # Taylor--Hood\n    #FETypes = [H1CR{2}, L2P0{1}] # Crouzeix--Raviart\n    #FETypes = [H1MINI{2,2}, H1P1{1}] # MINI element on triangles only\n    #FETypes = [H1MINI{2,2}, H1CR{1}] # MINI element on triangles/quads\n    FETypes = [H1BR{2}, L2P0{1}] # Bernardi--Raugel\n    #FETypes = [H1P2{2,2}, L2P1{1}]; barycentric_refinement = true # Scott-Vogelius\n\n    #####################################################################################\n    #####################################################################################\n\n    # load linear Stokes problem prototype and assign data\n    # we are adding the nonlinar convection term below\n    StokesProblem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false)\n    add_boundarydata!(StokesProblem, 1, [1,2,4], HomogeneousDirichletBoundary)\n    add_boundarydata!(StokesProblem, 1, [3], BestapproxDirichletBoundary; data = boundary_data_top!, bonus_quadorder = 0)\n\n    # store matrix of Laplace operator for nonlinear solver\n    StokesProblem.LHSOperators[1,1][1].store_operator = true\n\n    # add Newton for convection term\n    if ADnewton\n        # AUTOMATIC DIFFERENTATION\n        # requries AD kernel function for NonlinearForm action (u * grad) u\n        function ugradu_kernel_AD(result, input)\n            # input = [u, grad(u)]\n            # compute (u * grad) u = grad(u)*u\n            for j = 1 : 2\n                result[j] = 0.0\n                for k = 1 : 2\n                    result[j] += input[k]*input[2 + (j-1)*2+k]\n                end\n            end\n            return nothing\n        end\n\n        # generate and add nonlinear PDEOperator (modifications to RHS are taken care of automatically)\n        NLConvectionOperator = GenerateNonlinearForm(\"(u * grad) u  * v\", [Identity, Gradient], [1,1], Identity, ugradu_kernel_AD, [2, 6], 2; ADnewton = true)\n        add_operator!(StokesProblem, [1,1], NLConvectionOperator)\n    else\n        # MANUAL DIFFERENTATION\n        # uses the following kernel function\n        function ugradu_kernel_nonAD(result, input_current, input_ansatz)\n            # input_current = [current, grad(current)]\n            # input_ansatz = [ansatz, grad(ansatz)]\n            # compute (current * grad) ansatz + (current * grad) ansatz\n            for j = 1 : 2\n                result[j] = 0.0\n                for k = 1 : 2\n                    result[j] += input_current[k]*input_ansatz[2 + (j-1)*2+k]\n                    result[j] += input_ansatz[k]*input_current[2 + (j-1)*2+k]\n                end\n            end\n            return nothing\n        end\n        # and a similar kernel function for the RHS\n        function ugradu_kernel_rhs(result, input_current, input_ansatz)\n            # input_current = [current, grad(current)]\n            # input_ansatz = [ansatz, grad(ansatz)]\n            # compute (current * grad) current\n            for j = 1 : 2\n                result[j] = 0.0\n                for k = 1 : 2\n                    result[j] += input_current[k]*input_current[2 + (j-1)*2+k]\n                end\n            end\n            return nothing\n        end\n\n        # generate and add nonlinear PDEOperator (modifications to RHS are taken care of by optional arguments)\n        NLConvectionOperator = GenerateNonlinearForm(\"(u * grad) u  * v\", [Identity, Gradient], [1,1], Identity, ugradu_kernel_nonAD, [2, 6], 2; ADnewton = false, action_kernel_rhs = ugradu_kernel_rhs)\n        add_operator!(StokesProblem, [1,1], NLConvectionOperator)\n    end\n\n    # uniform mesh refinement, in case of Scott-Vogelius we use barycentric refinement\n    if barycentric_refinement == true\n        xgrid = barycentric_refine(xgrid)\n    end\n\n    # generate FESpaces\n    FESpaceVelocity = FESpace{FETypes[1]}(xgrid)\n    FESpacePressure = FESpace{FETypes[2]}(xgrid)\n    Solution = FEVector{Float64}(\"Stokes velocity\",FESpaceVelocity)\n    append!(Solution,\"Stokes pressure\",FESpacePressure)\n\n    # show configuration and solve Stokes problem\n    Base.show(StokesProblem)\n    solve!(Solution, StokesProblem; verbosity = verbosity, maxIterations = maxIterations, maxResidual = maxResidual)\n\n    # plot\n    GradientRobustMultiPhysics.plot(Solution, [1,2], [Identity, Identity]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\n\nend\n\nend","category":"page"},{"location":"examples/doc_2d_liddrivencavity_autonewton/","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"","category":"page"},{"location":"examples/doc_2d_liddrivencavity_autonewton/","page":"2D Lid-driven cavity (AD-Newton)","title":"2D Lid-driven cavity (AD-Newton)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_stokes_probust/#D-Pressure-robustness","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"","category":"section"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"(source code)","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"This example studies two benchmarks for pressure-robust discretisations of the stationary     Navier-Stokes equations that seek a velocity mathbfu and pressure mathbfp such that","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"with (possibly time-dependent) exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"Pressure-robustness is concerned with gradient forces that may appear in the right-hand side or the material derivative and should be balanced by the pressure (as divergence-free vector fields are orthogonal on gradient fields). Here, two test problems are considered:","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"HydrostaticTestProblem() : Stokes (without convection term) and mathbff = nabla p such that  mathbfu = 0\nPotentialFlowTestProblem() : Navier-Stokes with mathbff = 0 and mathbfu = nabla h for some harmonic function","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"In both test problems the errors of non-pressure-robust discretisations scale with  1mu, while the pressure-robust discretisation solves mathbfu = 0 exactly in test problem 1 and gives much better results in test problem 2.","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"module Example_2DPressureRobustness\n\nusing GradientRobustMultiPhysics\nusing Printf\n\n# problem data\nfunction HydrostaticTestProblem()\n    # Stokes problem with f = grad(p)\n    # u = 0\n    # p = x^3+y^3 - 1//2\n    function P1_pressure!(result,x)\n        result[1] = x[1]^3 + x[2]^3 - 1//2\n    end\n    function P1_velo!(result,x)\n        result[1] = 0.0;\n        result[2] = 0.0;\n    end\n    function P1_velogradient!(result,x)\n        result[1] = 0.0\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = 0.0;\n    end\n    function P1_rhs!(result,x)\n        result[1] = 3*x[1]^2\n        result[2] = 3*x[2]^2\n    end\n    return P1_pressure!, P1_velo!, P1_velogradient!, P1_rhs!, false\nend\n\nfunction PotentialFlowTestProblem()\n    # NavierStokes with f = 0\n    # u = grad(h) with h = x^3 - 3xy^2\n    # p = - |grad(h)|^2 + 14//5\n    function P2_pressure!(result,x)\n        result[1] = - 1//2 * (9*(x[1]^4 + x[2]^4) + 18*x[1]^2*x[2]^2) + 14//5\n    end\n    function P2_velo!(result,x)\n        result[1] = 3*x[1]^2 - 3*x[2]^2;\n        result[2] = -6*x[1]*x[2];\n    end\n    function P2_velogradient!(result,x)\n        result[1] = 6*x[1]\n        result[2] = -6*x[2];\n        result[3] = -6*x[2];\n        result[4] = -6*x[1];\n    end\n    function P2_rhs!(result,x)\n        result[1] = 0\n        result[2] = 0\n    end\n    return P2_pressure!, P2_velo!, P2_velogradient!, P2_rhs!, true\nend\n\n\nfunction solve(Problem, xgrid, FETypes, viscosity = 1e-2; nlevels = 3, print_results = true, verbosity = 1)\n\n    # load problem data and set solver parameters\n    exact_pressure!, exact_velocity!, exact_velocity_gradient!, rhs!, nonlinear = Problem()\n    maxIterations = 20  # termination criterion 1 for nonlinear mode\n    maxResidual = 1e-12 # termination criterion 2 for nonlinear mode\n\n    # load Stokes problem prototype and assign data\n    StokesProblem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = nonlinear)\n    add_boundarydata!(StokesProblem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = exact_velocity!, bonus_quadorder = 2)\n    add_rhsdata!(StokesProblem, 1, RhsOperator(ReconstructionIdentity, [0], rhs!, 2, 2; bonus_quadorder = 2))\n\n    # define bestapproximation problems\n    L2VelocityBestapproximationProblem = L2BestapproximationProblem(exact_velocity!, 2, 2; bestapprox_boundary_regions = [1,2,3,4], bonus_quadorder = 2)\n    L2PressureBestapproximationProblem = L2BestapproximationProblem(exact_pressure!, 2, 1; bestapprox_boundary_regions = [], bonus_quadorder = 4)\n    H1VelocityBestapproximationProblem = H1BestapproximationProblem(exact_velocity_gradient!, exact_velocity!, 2, 2; bestapprox_boundary_regions = [1,2,3,4], bonus_quadorder = 1, bonus_quadorder_boundary = 2)\n\n    # define ItemIntegrators for L2/H1 error computation\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(exact_velocity!, Identity, 2, 2; bonus_quadorder = 0)\n    L2PressureErrorEvaluator = L2ErrorIntegrator(exact_pressure!, Identity, 2, 1; bonus_quadorder = 3)\n    H1VelocityErrorEvaluator = L2ErrorIntegrator(exact_velocity_gradient!, Gradient, 2, 4; bonus_quadorder = 0)\n    L2error_velocity = []; L2error_pressure = []; L2error_velocity2 = []; L2error_pressure2 = []\n    L2errorInterpolation_velocity = []; L2errorInterpolation_pressure = []; L2errorBestApproximation_velocity = []; L2errorBestApproximation_pressure = []\n    H1error_velocity = []; H1error_velocity2 = []; H1errorBestApproximation_velocity = []; NDofs = []\n\n\n    # setup classical (StokesProblem) and pressure-robust scheme (StokesProblem2)\n    StokesProblem2 = deepcopy(StokesProblem)\n    StokesProblem.RHSOperators[1][1] = RhsOperator(Identity, [0], rhs!, 2, 2; bonus_quadorder = 2)\n    ReconstructionOperator = FETypes[3]\n    StokesProblem2.RHSOperators[1][1] = RhsOperator(ReconstructionOperator, [0], rhs!, 2, 2; bonus_quadorder = 2)\n    if nonlinear\n        StokesProblem.LHSOperators[1,1][1].store_operator = true # store matrix of Laplace operator\n        StokesProblem2.LHSOperators[1,1][1].store_operator = true # store matrix of Laplace operator\n        StokesProblem.LHSOperators[1,1][2] = ConvectionOperator(1, Identity, 2, 2)\n        StokesProblem2.LHSOperators[1,1][2] = ConvectionOperator(1, ReconstructionOperator, 2, 2; testfunction_operator = ReconstructionOperator)\n    end\n\n    # loop over refinement levels\n    for level = 1 : nlevels\n\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n        xFaceVolumes = xgrid[FaceVolumes]\n\n        # get FESpaces\n        FESpaceVelocity = FESpace{FETypes[1]}(xgrid)\n        FESpacePressure = FESpace{FETypes[2]}(xgrid)\n\n        Solution = FEVector{Float64}(\"Stokes velocity classical\",FESpaceVelocity)\n        append!(Solution,\"Stokes pressure (classical)\",FESpacePressure)\n        solve!(Solution, StokesProblem; maxIterations = maxIterations, maxResidual = maxResidual, verbosity = verbosity)\n        push!(NDofs,length(Solution.entries))\n\n        Solution2 = FEVector{Float64}(\"Stokes velocity p-robust\",FESpaceVelocity)\n        append!(Solution2,\"Stokes pressure (p-robust)\",FESpacePressure)\n        solve!(Solution2, StokesProblem2; maxIterations = maxIterations, maxResidual = maxResidual)\n\n        # solve bestapproximation problems\n        L2VelocityBestapproximation = FEVector{Float64}(\"L2-Bestapproximation velocity\",FESpaceVelocity)\n        L2PressureBestapproximation = FEVector{Float64}(\"L2-Bestapproximation pressure\",FESpacePressure)\n        H1VelocityBestapproximation = FEVector{Float64}(\"H1-Bestapproximation velocity\",FESpaceVelocity)\n        solve!(L2VelocityBestapproximation, L2VelocityBestapproximationProblem)\n        solve!(L2PressureBestapproximation, L2PressureBestapproximationProblem)\n        solve!(H1VelocityBestapproximation, H1VelocityBestapproximationProblem)\n\n        # compute L2 and H1 error\n        append!(L2error_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1])))\n        append!(L2error_velocity2,sqrt(evaluate(L2VelocityErrorEvaluator,Solution2[1])))\n        append!(L2errorBestApproximation_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,L2VelocityBestapproximation[1])))\n        append!(L2error_pressure,sqrt(evaluate(L2PressureErrorEvaluator,Solution[2])))\n        append!(L2error_pressure2,sqrt(evaluate(L2PressureErrorEvaluator,Solution2[2])))\n        append!(L2errorBestApproximation_pressure,sqrt(evaluate(L2PressureErrorEvaluator,L2PressureBestapproximation[1])))\n        append!(H1error_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,Solution[1])))\n        append!(H1error_velocity2,sqrt(evaluate(H1VelocityErrorEvaluator,Solution2[1])))\n        append!(H1errorBestApproximation_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,H1VelocityBestapproximation[1])))\n\n        # print results\n        if (level == nlevels) && (print_results)\n            println(\"\\n         |   L2ERROR    |   L2ERROR    |   L2ERROR\")\n            println(\"   NDOF  | VELO-CLASSIC | VELO-PROBUST | VELO-L2BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.6e |\",L2error_velocity[j])\n                @printf(\" %.6e |\",L2error_velocity2[j])\n                @printf(\" %.6e\\n\",L2errorBestApproximation_velocity[j])\n            end\n            println(\"\\n         |   H1ERROR    |   H1ERROR    |   H1ERROR\")\n            println(\"   NDOF  | VELO-CLASSIC | VELO-PROBUST | VELO-H1BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.6e |\",H1error_velocity[j])\n                @printf(\" %.6e |\",H1error_velocity2[j])\n                @printf(\" %.6e\\n\",H1errorBestApproximation_velocity[j])\n            end\n            println(\"\\n         |   L2ERROR    |   L2ERROR    |   L2ERROR\")\n            println(\"   NDOF  | PRES-CLASSIC | PRES-PROBUST | PRES-L2BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.6e |\",L2error_pressure[j])\n                @printf(\" %.6e |\",L2error_pressure2[j])\n                @printf(\" %.6e\\n\",L2errorBestApproximation_pressure[j])\n            end\n            println(\"\\nLEGEND\\n======\")\n            println(\"VELO-CLASSIC : discrete Stokes velocity solution ($(FESpaceVelocity.name)) with classical discretisation\")\n            println(\"VELO-PROBUST : discrete Stokes velocity solution ($(FESpaceVelocity.name)) with p-robust discretisation\")\n            println(\"VELO-L2BEST : L2-Bestapproximation of exact velocity (with boundary data)\")\n            println(\"VELO-H1BEST : H1-Bestapproximation of exact velocity (with boudnary data)\")\n            println(\"PRES-CLASSIC : discrete Stokes pressure solution ($(FESpacePressure.name)) with classical discretisation\")\n            println(\"PRES-PROBUST : discrete Stokes pressure solution ($(FESpaceVelocity.name)) with p-robust discretisation\")\n            println(\"PRES-L2BEST : L2-Bestapproximation of exact pressure (without boundary data)\")\n        end\n    end\n\n    # return last error for testing\n    return L2error_velocity2[end]\nend\n\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, nlevels = 4, viscosity = 1e-2)\n    # set problem to solve\n    #Problem = HydrostaticTestProblem\n    Problem = PotentialFlowTestProblem\n\n    # set grid and problem parameters\n    xgrid = grid_unitsquare_mixedgeometries() # initial grid\n\n    # choose finite element discretisation\n    #FETypes = [H1BR{2}, L2P0{1}, ReconstructionIdentity{HDIVRT0{2}}] # Bernardi--Raugel with RT0 reconstruction\n    FETypes = [H1BR{2}, L2P0{1}, ReconstructionIdentity{HDIVBDM1{2}}] # Bernardi--Raugel with BDM1 reconstruction\n    #FETypes = [H1CR{2}, L2P0{1}, ReconstructionIdentity{HDIVRT0{2}}] # Crouzeix--Raviart with RT0 reconstruction\n\n    # run\n    solve(Problem, xgrid, FETypes, viscosity; nlevels = nlevels, verbosity = verbosity)\nend\n\n\n# test function that is called by test unit\n# tests if hydrostatic problem is solved exactly by pressure-robust methods\nfunction test(; verbosity = 0)\n    xgrid = uniform_refine(grid_unitsquare_mixedgeometries())\n\n    testspaces = [[H1CR{2}, L2P0{1}, ReconstructionIdentity{HDIVRT0{2}}],\n                  [H1BR{2}, L2P0{1}, ReconstructionIdentity{HDIVRT0{2}}],\n                  [H1BR{2}, L2P0{1}, ReconstructionIdentity{HDIVBDM1{2}}]]\n    error = []\n    for FETypes in testspaces\n        push!(error, solve(HydrostaticTestProblem, xgrid, FETypes, 1; nlevels = 1, print_results = false, verbosity = verbosity))\n        println(\"FETypes = $FETypes   error = $(error[end])\")\n    end\n    return maximum(error)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_intro/#How-to-run-the-examples","page":"How to run the examples","title":"How to run the examples","text":"","category":"section"},{"location":"examples_intro/","page":"How to run the examples","title":"How to run the examples","text":"Note that all examples are written inside their own modules. To start an example you usually have to include the file and then run the main() function from the example module. Some examples have optional argument, e.g. Plotter = PyPlot, produces some plots with PyPlot (using PyPlot reuqired beforehand). Other Plotters are not yet supported.","category":"page"},{"location":"examples_intro/","page":"How to run the examples","title":"How to run the examples","text":"Here is an example how to start the example in \"examples/doc2dcompressiblestokes.jl\":","category":"page"},{"location":"examples_intro/","page":"How to run the examples","title":"How to run the examples","text":"# include example file, e.g.:\ninclude(\"examples/doc_2d_compressiblestokes.jl\")\n# as a result some module is loaded, in this case Example_2DCompressibleStokes\n\n# run without graphics output\nExample_2DCompressibleStokes.main()\n\n# run with PyPlot graphics output\nusing PyPlot\nExample_2DCompressibleStokes.main(; Plotter = PyPlot)","category":"page"},{"location":"examples_intro/","page":"How to run the examples","title":"How to run the examples","text":"Also note, that if you make changes to the example files you have to include them again!","category":"page"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Meshes are stored as an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl","category":"page"},{"location":"meshing/#Available-mesh-manipulations","page":"Meshing","title":"Available mesh manipulations","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"meshrefinements.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"meshing/#GradientRobustMultiPhysics.barycentric_refine-Union{Tuple{ExtendableGrid{T,K}}, Tuple{K}, Tuple{T}} where K where T","page":"Meshing","title":"GradientRobustMultiPhysics.barycentric_refine","text":"generates a new ExtendableGrid by barycentric refinement of each cell in the source grid\n\nbarcentric refinement is available for these ElementGeometries     - Quadrilateral2D (first split into Triangle2D)     - Triangle2D\n\n\n\n\n\n","category":"method"},{"location":"meshing/#GradientRobustMultiPhysics.split_grid_into-Union{Tuple{K}, Tuple{T}, Tuple{ExtendableGrid{T,K},Type{var\"#s13\"} where var\"#s13\"<:AbstractElementGeometry}} where K where T","page":"Meshing","title":"GradientRobustMultiPhysics.split_grid_into","text":"split_grid_into(source_grid::ExtendableGrid{T,K}, targetgeometry::Type{var\"#s13\"} where var\"#s13\"<:AbstractElementGeometry) -> ExtendableGrid{_A,_B} where _B where _A\n\n\ngenerates a new ExtendableGrid by splitting each cell into subcells of the specified targetgeometry\n\nsplit rules exist for     - Quadrilateral2D into Triangle2D\n\n\n\n\n\n","category":"method"},{"location":"meshing/#GradientRobustMultiPhysics.uniform_refine-Union{Tuple{ExtendableGrid{T,K}}, Tuple{K}, Tuple{T}} where K where T","page":"Meshing","title":"GradientRobustMultiPhysics.uniform_refine","text":"generates a new ExtendableGrid by uniform refinement of each cell in the given grid\n\nuniform refinement rules are available for these AbstractElementGeometries:     - Line1D (bisection into two subsegments)     - Triangle2D (red refinement into four subtriangles)     - Quadrilateral2D (into four subquadrilaterals)     - Tetrahedron (into eight subtetrahedrons)     - Hexahedron (into eight subhexahedrons)\n\nif multiple geometries are in the mesh uniform refinement will only work if all refinement rules refine faces and edges (in 3D) equally (so no hanging nodes are created)\n\n\n\n\n\n","category":"method"},{"location":"examples/doc_2d_convectiondiffusion/#D-Convection-Diffusion-Problem","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"","category":"section"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"(source code)","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"This example computes the solution of some convection-diffusion problem","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"-nu Delta u + mathbfbeta cdot nabla u = f quad textin  Omega","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"with some diffusion coefficient  nu, some vector-valued function  mathbfbeta and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"We prescribe an analytic solution and check the L2 and H1 error convergence of the method on a series of uniformly refined meshes. We also compare with the error of a simple nodal interpolation and plot the solution and the norm of its gradient.","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"For small nu, the convection term dominates and pollutes the accuracy of the method. For demonstration some simple gradient jump (interior penalty) stabilisation is added to improve things.","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"module Example_2DConvectionDiffusion\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n\n# problem data and expected exact solution\nfunction exact_solution!(result,x)\n    result[1] = x[1]*x[2]*(x[1]-1)*(x[2]-1) + x[1]\nend\nfunction exact_solution_gradient!(result,x)\n    result[1] = x[2]*(2*x[1]-1)*(x[2]-1) + 1.0\n    result[2] = x[1]*(2*x[2]-1)*(x[1]-1)\nend\nfunction beta!(result,x)\n    result[1] = 1.0\n    result[2] = 0.0\nend\nfunction exact_solution_rhs!(diffusion)\n    function closure(result,x)\n        # diffusion part\n        result[1] = -diffusion*(2*x[2]*(x[2]-1) + 2*x[1]*(x[1]-1))\n        # convection part (beta * grad(u))\n        result[1] += x[2]*(2*x[1]-1)*(x[2]-1) + 1.0\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1, Plotter = nothing, diffusion = 1e-5, stabilisation = 2e-2, nlevels = 5)\n\n    # load a mesh of the unit square (this one has triangles and quads in it)\n    # it also has four boundary regions (1 = bottom, 2 = right, 3 = top, 4 = left)\n    # used below to prescribe the boundary data\n    xgrid = grid_unitsquare_mixedgeometries(); # initial grid\n\n    # choose a finite element type, here we choose a second order H1-conforming one\n    FEType = H1P2{1,2}\n\n    # create PDE description = start with Poisson problem and add convection operator to block [1,1] and change equation name\n    Problem = PoissonProblem(2; diffusion = diffusion)\n    add_operator!(Problem, [1,1], ConvectionOperator(beta!,2,1); equation_name = \"convection diffusion equation\")\n\n    # add right-hand side data to equation 1 (there is only one in this example)\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], exact_solution_rhs!(diffusion), 2, 1; bonus_quadorder = 3))\n\n    # add boundary data to unknown 1 (there is only one in this example)\n    # on boundary regions where the solution is linear only need to be interpolated\n    # on boundary regions where the solution is zero only homoegeneous boundary conditions are needed\n    add_boundarydata!(Problem, 1, [1,3], BestapproxDirichletBoundary; data = exact_solution!, bonus_quadorder = 2)\n    add_boundarydata!(Problem, 1, [2], InterpolateDirichletBoundary; data = exact_solution!)\n    add_boundarydata!(Problem, 1, [4], HomogeneousDirichletBoundary)","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"add a gradient jump (interior penalty) stabilisation for dominant convection","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"    if stabilisation > 0\n        xFaceVolumes = xgrid[FaceVolumes]\n        function stabilisation_kernel(result, input, item)\n            for j = 1 : length(input)\n                result[j] = input[j] * stabilisation * xFaceVolumes[item]^2\n            end\n        end\n        JumpStabilisation = AbstractBilinearForm(\"[grad(u)] [grad(v)]\", GradientDisc{Jump}, GradientDisc{Jump}, ItemWiseFunctionAction(stabilisation_kernel,[2, 2]); AT = ON_IFACES)\n        add_operator!(Problem, [1,1], JumpStabilisation)\n    end\n\n    # finally we have a look at the problem\n    show(Problem)\n\n    # define ItemIntegrators for L2/H1 error computation and some arrays to store the errors\n    L2ErrorEvaluator = L2ErrorIntegrator(exact_solution!, Identity, 2, 1; bonus_quadorder = 4)\n    H1ErrorEvaluator = L2ErrorIntegrator(exact_solution_gradient!, Gradient, 2, 2; bonus_quadorder = 3)\n    L2error = []; H1error = []; L2errorInterpolation = []; H1errorInterpolation = []; NDofs = []\n\n    # refinement loop over levels\n    for level = 1 : nlevels\n\n        # uniform mesh refinement\n        if (level > 1)\n            xgrid = uniform_refine(xgrid)\n        end\n\n        # generate FESpace\n        FES = FESpace{FEType}(xgrid)\n        xFaceVolumes = xgrid[FaceVolumes] # update xFaceVolumes used in stabilisation definition\n\n        # solve PDE\n        Solution = FEVector{Float64}(\"Problem solution\",FES)\n        solve!(Solution, Problem; verbosity = verbosity)\n        push!(NDofs,length(Solution.entries))\n\n        # interpolate\n        Interpolation = FEVector{Float64}(\"Interpolation\",FES)\n        interpolate!(Interpolation[1], exact_solution!; bonus_quadorder = 4, verbosity = verbosity)\n\n        # compute L2 and H1 error\n        append!(L2error,sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\n        append!(L2errorInterpolation,sqrt(evaluate(L2ErrorEvaluator,Interpolation[1])))\n        append!(H1error,sqrt(evaluate(H1ErrorEvaluator,Solution[1])))\n        append!(H1errorInterpolation,sqrt(evaluate(H1ErrorEvaluator,Interpolation[1])))\n\n        if (level == nlevels)\n            # print error history\n            println(\"\\n         |   L2ERROR   |   L2ERROR\")\n            println(\"   NDOF  |   SOLUTION  |   INTERPOL\");\n            for j=1:nlevels\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e |\",L2error[j])\n                @printf(\" %.5e\\n\",L2errorInterpolation[j])\n            end\n            println(\"\\n         |   H1ERROR   |   H1ERROR\")\n            println(\"   NDOF  |   SOLUTION  |   INTERPOL\");\n            for j=1:nlevels\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e |\",H1error[j])\n                @printf(\" %.5e\\n\",H1errorInterpolation[j])\n            end\n\n            # plot\n            GradientRobustMultiPhysics.plot(Solution, [1,1], [Identity, Gradient]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\n        end\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_jumpestimator/#D-Jump-Estimator","page":"2D Jump-Estimator","title":"2D Jump-Estimator","text":"","category":"section"},{"location":"examples/doc_2d_jumpestimator/","page":"2D Jump-Estimator","title":"2D Jump-Estimator","text":"(source code)","category":"page"},{"location":"examples/doc_2d_jumpestimator/","page":"2D Jump-Estimator","title":"2D Jump-Estimator","text":"This example calculates an error estimator for an Hdiv approximation by evaluating the jump over all faces, i.e.","category":"page"},{"location":"examples/doc_2d_jumpestimator/","page":"2D Jump-Estimator","title":"2D Jump-Estimator","text":"eta^2(sigma) = sum_F in mathcalF mathrmdiam(F)  sigma ^2_L^2(F)","category":"page"},{"location":"examples/doc_2d_jumpestimator/","page":"2D Jump-Estimator","title":"2D Jump-Estimator","text":"where sigma is some finite element function. Here, we check the error of some Hdiv-conforming L2 bestapproximation. (In future updates adaptive mesh refinement may be possible based on these indicators)","category":"page"},{"location":"examples/doc_2d_jumpestimator/","page":"2D Jump-Estimator","title":"2D Jump-Estimator","text":"module Example_2DJumpEstimator\n\nusing GradientRobustMultiPhysics\n\n# define some vector field that should be approximated\nfunction exact_function!(result,x)\n    result[1] = x[1]^3+x[2]^2\n    result[2] = -x[1]^2 + x[2] + 1\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1)\n\n    # generate a unit square mesh and refine\n    xgrid = simplexgrid([0.0,1.0],[0.0,1.0])\n    xgrid = uniform_refine(xgrid, 5)\n\n    # setup a bestapproximation problem via a predefined prototype\n    Problem = L2BestapproximationProblem(exact_function!, 2, 2; bestapprox_boundary_regions = [1,2,3,4], bonus_quadorder = 3)\n\n    # choose some (inf-sup stable) finite element types\n    FEType = HDIVBDM1{2}\n    FES = FESpace{FEType}(xgrid)\n\n    # create a solution vector and solve the problem\n    Solution = FEVector{Float64}(\"L2-Bestapproximation\",FES)\n    solve!(Solution, Problem; verbosity = verbosity)\n\n    # calculate estimator by evaluating the jumps on faces\n    xFaceVolumes = xgrid[FaceVolumes]\n    xFaceCells = xgrid[FaceCells]\n    function L2jump_integrand(result, input, item)\n        # input = [IdentityDisc{Jump}]\n        for j = 1 : length(input)\n            result[j] = input[j]^2 * xFaceVolumes[item]\n        end\n        return nothing\n    end\n    jumpIntegrator = ItemIntegrator{Float64,ON_IFACES}(IdentityDisc{Jump},ItemWiseFunctionAction(L2jump_integrand, [2,2]; bonus_quadorder = 2), [0])\n    println(\"\\nEstimator = $(sqrt(sum(evaluate(jumpIntegrator,[Solution[1]]))))\")\n\n    # calculate L2 error and print results\n    L2ErrorEvaluator = L2ErrorIntegrator(exact_function!, Identity, 2, 2)\n    println(\"L2error(Id) = $(sqrt(evaluate(L2ErrorEvaluator,[Solution[1]])))\")\n\nend\n\nend","category":"page"},{"location":"examples/doc_2d_jumpestimator/","page":"2D Jump-Estimator","title":"2D Jump-Estimator","text":"","category":"page"},{"location":"examples/doc_2d_jumpestimator/","page":"2D Jump-Estimator","title":"2D Jump-Estimator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_3d_elasticity/#D-Linear-Elasticity","page":"3D Linear Elasticity","title":"3D Linear Elasticity","text":"","category":"section"},{"location":"examples/doc_3d_elasticity/","page":"3D Linear Elasticity","title":"3D Linear Elasticity","text":"(source code)","category":"page"},{"location":"examples/doc_3d_elasticity/","page":"3D Linear Elasticity","title":"3D Linear Elasticity","text":"This example computes the solution mathbfu of the linear elasticity problem","category":"page"},{"location":"examples/doc_3d_elasticity/","page":"3D Linear Elasticity","title":"3D Linear Elasticity","text":"beginaligned\n-mathrmdiv (mathbbC epsilon(mathbfu))  = mathbff quad textin  Omega\nmathbbC epsilon(mathbfu) cdot mathbfn  = mathbfg quad textalong  Gamma_N\nendaligned","category":"page"},{"location":"examples/doc_3d_elasticity/","page":"3D Linear Elasticity","title":"3D Linear Elasticity","text":"with exterior force mathbff, Neumann boundary force mathbfg, and the stiffness tensor mathbbC for isotropic media.","category":"page"},{"location":"examples/doc_3d_elasticity/","page":"3D Linear Elasticity","title":"3D Linear Elasticity","text":"module Example_3DElasticity\n\nusing GradientRobustMultiPhysics\n\n# problem data for Neumann boundary\nfunction neumann_force_right!(result,x)\n    result[1] = 0.0\n    result[2] = 0.0\n    result[3] = 10.0\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1)\n\n    # mesh = scaled unit cube and 3 uniform refinements\n    xgrid = uniform_refine(grid_unitcube(Parallelepiped3D; scale = [4//3,3//4,1//4]), 3)\n    #xgrid = split_grid_into(xgrid, Tetrahedron3D)\n\n    # parameters for isotropic elasticity tensor\n    elasticity_modulus = 1000 # elasticity modulus\n    poisson_number = 1//3 # Poisson number\n    shear_modulus = (1/(2+2*poisson_number))*elasticity_modulus\n    lambda = poisson_number*elasticity_modulus/((1-2*poisson_number)*3*(1+poisson_number))\n\n    # choose finite element type\n    FEType = H1P1{3} # P1-Courant\n\n    #####################################################################################\n    #####################################################################################\n\n    # PDE description via prototype\n    LinElastProblem = LinearElasticityProblem(3; shear_modulus = shear_modulus, lambda = lambda)\n\n    # add Neumann boundary data on right side\n    add_rhsdata!(LinElastProblem, 1,  RhsOperator(Identity, [3], neumann_force_right!, 3, 3; on_boundary = true, bonus_quadorder = 0))\n\n    # add Dirichlet boundary data on left side\n    add_boundarydata!(LinElastProblem, 1, [5], HomogeneousDirichletBoundary)\n\n    # show problem definition\n    show(LinElastProblem)\n\n    # generate FESpace\n    FES = FESpace{FEType}(xgrid)\n\n    # solve PDE\n    Solution = FEVector{Float64}(\"displacement\",FES)\n    solve!(Solution, LinElastProblem; verbosity = verbosity)\n\n    # write to vtk\n    mkpath(\"data/example_3delasticity/\")\n    writeVTK!(\"data/example_3delasticity/results.vtk\", Solution)\n\nend\n\nend","category":"page"},{"location":"examples/doc_3d_elasticity/","page":"3D Linear Elasticity","title":"3D Linear Elasticity","text":"","category":"page"},{"location":"examples/doc_3d_elasticity/","page":"3D Linear Elasticity","title":"3D Linear Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fems/#Implemented-Finite-Elements","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"This page describes the finite element type-tree and lists all implemented finite elements.","category":"page"},{"location":"fems/#The-Finite-Element-Type-Tree","page":"Implemented Finite Elements","title":"The Finite Element Type-Tree","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Finite elements are abstract type leaves in a type-tree. Its root and first layer look like this","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"AbstractFiniteElements","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"AbstractH1FiniteElement\nAbstractHdivFiniteElement\nAbstractHcurlFiniteElement\nAbstractL2FiniteElement","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Remarks:","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"each finite elements mainly comes with a set of basis functions in reference coordinates for each applicable AbstractElementGeometry and a generator for the degrees of freedom map of a FESpace\nthe type steers how the basis functions are transformed from local to global coordinates and how FunctionOperators are evaluated by FEBasisEvaluator.jl\ndepending on additional continuity properties of the element types more basis function sets are defined:\nAbstractH1FiniteElements additionally have evaluations of nonzero basisfunctions on faces/bfaces\nAbstractHdivFiniteElements additionally have evaluations of nonzero normalfluxes of basisfunctions on faces/bfaces","category":"page"},{"location":"fems/#List-of-implemented-Finite-Elements","page":"Implemented Finite Elements","title":"List of implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The following table lists all curently implemented finite elements. Click on them to find out more details.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1 finite elements Hdiv finite elements Hcurl finite elements L2 finite elements\nH1P1 HDIVRT0  L2P0\nH1MINI HDIVBDM1  L2P1\nH1P2 HDIVRT1  \nH1BR   \nH1CR   ","category":"page"},{"location":"fems/#Details","page":"Implemented Finite Elements","title":"Details","text":"","category":"section"},{"location":"fems/#H1-conforming-finite-elements","page":"Implemented Finite Elements","title":"H1-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P1\nH1MINI\nH1P2\nH1CR\nH1BR","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P1","text":"abstract type H1P1 <: AbstractH1FiniteElement\n\nContinuous piecewise first-order polynomials with arbitrary number of components.\n\nallowed ElementGeometries:\n\nEdge1D (linear polynomials)\nTriangle2D (linear polynomials)\nQuadrilateral2D (Q1 space)\nTetrahedron3D (linear polynomials)\nHexahedron3D (Q1 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.H1MINI","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1MINI","text":"abstract type H1MINI <: AbstractH1FiniteElement\n\nMini finite element (continuous piecewise linear + cell bubbles)\n\nallowed element geometries:\n\nTriangle2D (linear polynomials + cubic cell bubble)\nQuadrilateral2D (Q1 space + quartic cell bubble)\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.H1P2","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P2","text":"abstract type H1P2 <: AbstractH1FiniteElement\n\nContinuous piecewise second-order polynomials\n\nallowed ElementGeometries:\n\nEdge1D (quadratic polynomials)\nTriangle2D (quadratic polynomials)\nQuadrilateral2D (Q2 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.H1CR","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1CR","text":"abstract type H1CR <: AbstractH1FiniteElement\n\nCrouzeix-Raviart element (only continuous at face centers)\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear, similar to P1)\nQuadrilateral2D (similar to Q1 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.H1BR","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1BR","text":"abstract type H1BR <: AbstractH1FiniteElementWithCoefficients\n\nvector-valued (ncomponents = edim) Bernardi–Raugel element (first-order polynomials + normal-weighted face bubbles)\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear + normale-weighted face bubbles)\nQuadrilateral2D (Q1 space + normal-weighted face bubbles)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hdiv-conforming-finite-elements","page":"Implemented Finite Elements","title":"Hdiv-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"HDIVRT0\nHDIVBDM1\nHDIVRT1","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.HDIVRT0","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVRT0","text":"abstract type HDIVRT0 <: AbstractHdivFiniteElement\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Raviart-Thomas space\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\nHexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.HDIVBDM1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVBDM1","text":"abstract type HDIVBDM1 <: AbstractHdivFiniteElement\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Brezzi-Douglas-Marini space\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.HDIVRT1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVRT1","text":"abstract type HDIVRT1 <: AbstractHdivFiniteElement\n\nHdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of order 1\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hcurl-conforming-finite-elements","page":"Implemented Finite Elements","title":"Hcurl-conforming finite elements","text":"","category":"section"},{"location":"fems/#L2-conforming-finite-elements","page":"Implemented Finite Elements","title":"L2-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"L2P0\nL2P1","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.L2P0","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.L2P0","text":"abstract type L2P0 <: AbstractH1FiniteElement\n\npiecewise constant polynomials\n\nallowed on every ElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.L2P1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.L2P1","text":"abstract type L2P1 <: AbstractH1FiniteElement\n\ndiscontinuous piecewise first-order polynomials (same as H1P1 but with other dofmap)\n\nallowed ElementGeometries:\n\nEdge1D (linear polynomials)\nTriangle2D (linear polynomials)\nQuadrilateral2D (Q1 space)\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/#PDE-Solvers","page":"PDE Solvers","title":"PDE Solvers","text":"","category":"section"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"If solve! is applied to a PDEDescription and a FEVector (that specifies the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. Additionally the user can manually trigger subiterations that splits the fixed-point algorithm into substeps where only subsets of the PDE equations are solved together.","category":"page"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"Also, there is a preliminary time-dependent solver that can be setup in a similar manner and then performs the subiterations once in eachtimestep. As a TimeIntegrationRule so far only BackwardEuler is implemented.","category":"page"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"solvers.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdesolvers/#GradientRobustMultiPhysics.TimeControlSolver","page":"PDE Solvers","title":"GradientRobustMultiPhysics.TimeControlSolver","text":"function TimeControlSolver(\n    PDE::PDEDescription,\n    Solution::FEVector,    # contains initial values and stores solution of advance method below\n    TIR::Type{<:AbstractTimeIntegrationRule} = BackwardEuler;\n    timedependent_equations = [],\n    subiterations = \"auto\",\n    start_time::Real = 0,\n    verbosity::Int = 0,\n    dt_testfunction_operator = [],\n    dt_action = [],\n    nonlinear_dt::Bool = false,\n    dirichlet_penalty = 1e60)\n\nCreates a time-dependent solver that can be advanced in time with advance!. The FEVector Solution stores the initial state but also the solutions of each timestep. The field timedependent_equations contains the equation numbers (=rows in PDEDescription) that are time-dependent. The field subiterations specifies subsets of equations that are solved together in the given order; \"auto\" tries to solve the whole system at once.\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/#GradientRobustMultiPhysics.advance!","page":"PDE Solvers","title":"GradientRobustMultiPhysics.advance!","text":"advance!(TCS::TimeControlSolver) -> Array{Float64,2}\nadvance!(TCS::TimeControlSolver, timestep::Real) -> Array{Float64,2}\n\n\nAdvances a TimeControlSolver in time with the given timestep.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/#GradientRobustMultiPhysics.solve!-Tuple{FEVector,PDEDescription}","page":"PDE Solvers","title":"GradientRobustMultiPhysics.solve!","text":"solve!(Target::FEVector, PDE::PDEDescription; subiterations, dirichlet_penalty, time, maxResidual, maxIterations, linsolver, maxlureuse, AndersonIterations, verbosity)\n\n\nSolves a given PDE (provided as a PDEDescription) and writes the solution into the FEVector Target. The ansatz spaces are taken from the of this vector. The field subiterations specifies subsets of equations that are solved together in the given order; \"auto\" tries to solve the whole system at once, but also might resort to a fixed-point iteration if a nonlinearity is detected.\n\n\n\n\n\n","category":"method"},{"location":"examples/doc_2d_liddrivencavity_anderson/#D-Lid-driven-cavity-(Anderson-Iteration)","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"","category":"section"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"(source code)","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"This example solves the lid-driven cavity problem where one seeks a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"where mathbfu = (10) along the top boundary of a square domain.","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"For small viscosities (where a Newton and a classical Picard iteration do not converge anymore), Anderson acceleration might help (see https://arxiv.org/pdf/1810.08494.pdf) which can be tested with this script.","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"module Example_2DLidDrivenCavityAnderson\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# data\nfunction boundary_data_top!(result,x)\n    result[1] = 1.0;\n    result[2] = 0.0;\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 2, Plotter = nothing, viscosity = 1e-3, anderson_iterations = 5)\n\n    # grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), 5);\n\n    # problem parameters\n    maxIterations = 50  # termination criterion 1 for nonlinear mode\n    maxResidual = 1e-10 # termination criterion 2 for nonlinear mode\n    barycentric_refinement = false # do not change\n\n    # choose one of these (inf-sup stable) finite element type pairs\n    #FETypes = [H1P2{2,2}, H1P1{1}] # Taylor--Hood\n    #FETypes = [H1CR{2}, L2P0{1}] # Crouzeix--Raviart\n    #FETypes = [H1MINI{2,2}, H1P1{1}] # MINI element on triangles only\n    #FETypes = [H1MINI{2,2}, H1CR{1}] # MINI element on triangles/quads\n    FETypes = [H1BR{2}, L2P0{1}] # Bernardi--Raugel\n    #FETypes = [H1P2{2,2}, L2P1{1}]; barycentric_refinement = true # Scott-Vogelius\n\n    #####################################################################################\n    #####################################################################################\n\n    # load Stokes problem prototype and assign data\n    StokesProblem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = true)\n    add_boundarydata!(StokesProblem, 1, [1,2,4], HomogeneousDirichletBoundary)\n    add_boundarydata!(StokesProblem, 1, [3], BestapproxDirichletBoundary; data = boundary_data_top!, bonus_quadorder = 0)\n\n    # uniform mesh refinement\n    # in case of Scott-Vogelius we use barycentric refinement\n    if barycentric_refinement == true\n        xgrid = barycentric_refine(xgrid)\n    end\n\n    # generate FESpaces\n    FESpaceVelocity = FESpace{FETypes[1]}(xgrid)\n    FESpacePressure = FESpace{FETypes[2]}(xgrid)\n    Solution = FEVector{Float64}(\"Stokes velocity\",FESpaceVelocity)\n    append!(Solution,\"Stokes pressure\",FESpacePressure)\n\n    # set nonlinear options and Newton terms\n    StokesProblem.LHSOperators[1,1][1].store_operator = true\n    Base.show(StokesProblem)\n\n    # solve Stokes problem\n    solve!(Solution, StokesProblem; verbosity = verbosity, AndersonIterations = anderson_iterations, maxIterations = maxIterations, maxResidual = maxResidual)\n\n    # plot\n    GradientRobustMultiPhysics.plot(Solution, [1,2], [Identity, Identity]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\n\nend\n\nend","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson-Iteration)","title":"2D Lid-driven cavity (Anderson-Iteration)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_transientstokes/#D-Transient-Stokes-Problem","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"","category":"section"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"(source code)","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"beginaligned\nmathbfu_t - mu Delta mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"with (possibly time-dependent) exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"In this example we solve an analytical toy problem with prescribed solution","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"beginaligned\nmathbfu(mathbfxt)  = (1+t)(cos(x_2) sin(x_1))^T\np(mathbfx) = sin(x_1+x_2) - 2sin(1) + sin(2)\nendaligned","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"with time-dependent right-hand side and inhomogeneous Dirichlet boundary data. The example showcases the benefits of pressure-robustness in time-dependent linear Stokes problem in presence of complicated pressures and small viscosities. The problem is solved on series of finer and finer unstructured simplex meshes and compares the error of the discrete Stokes solution, an interpolation into the same space and the best-approximations into the same space. While a pressure-robust variant shows optimally converging errors close to the best-approximations, a non pressure-robust discretisations show suboptimal (or no) convergence! Compare e.g. Bernardi–Raugel and Bernardi–Raugel pressure-robust by (un)commenting the responsible lines in this example.","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"module Example_2DTransientStokes\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n\n# problem data\nfunction exact_pressure!(result,x)\n    result[1] = sin(x[1]+x[2]) - 2*sin(1)+sin(2)\nend\nfunction exact_velocity!(result,x,t)\n    result[1] = (1+t)*cos(x[2]);\n    result[2] = (1+t)*sin(x[1]);\nend\nfunction exact_velocity_gradient!(result,x,t)\n    result[1] = 0.0\n    result[2] = -(1+t)*sin(x[2]);\n    result[3] = (1+t)*cos(x[1]);\n    result[4] = 0.0;\nend\nfunction exact_rhs!(viscosity)\n    function closure(result,x,t)\n        result[1] = viscosity*(1+t)*cos(x[2]) + cos(x[1]+x[2]) + cos(x[2])\n        result[2] = viscosity*(1+t)*sin(x[1]) + cos(x[1]+x[2]) + sin(x[1])\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 2, Plotter = nothing)\n\n    # problem parameters\n    viscosity = 1e-6\n    timestep = 1e-3\n    T = 1e-2 # final time\n    nlevels = 4 # maximal number of refinement levels\n    reconstruct = false # do not change\n    graddiv = 0\n\n    # initial grid\n    xgrid = grid_unitsquare(Triangle2D);\n\n    # choose one of these (inf-sup stable) finite element type pairs\n    #FETypes = [H1P2{2,2}, H1P1{1}] # Taylor--Hood\n    #FETypes = [H1CR{2}, L2P0{1}] # Crouzeix--Raviart\n    #FETypes = [H1CR{2}, L2P0{1}]; reconstruct = true # Crouzeix-Raviart gradient-robust\n    #FETypes = [H1MINI{2,2}, H1P1{1}] # MINI element on triangles only\n    #FETypes = [H1MINI{2,2}, H1CR{1}] # MINI element on triangles/quads\n    FETypes = [H1BR{2}, L2P0{1}] # Bernardi--Raugel\n    #FETypes = [H1BR{2}, L2P0{1}]; reconstruct = true # Bernardi--Raugel gradient-robust\n\n    #####################################################################################\n    #####################################################################################\n\n    # set testfunction operator for certain testfunctions\n    # (pressure-robustness chooses a reconstruction that can exploit the L2-orthogonality onto gradients)\n    # (Scott-Vogelius is divergence-free and is pressure-robust without modifications)\n    if reconstruct\n        testfunction_operator = ReconstructionIdentity{HDIVBDM1{2}}\n    else\n        testfunction_operator = Identity\n    end\n\n    # load Stokes problem prototype and assign data\n    StokesProblem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false)\n    add_boundarydata!(StokesProblem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = exact_velocity!, bonus_quadorder = 5)\n    add_rhsdata!(StokesProblem, 1, RhsOperator(testfunction_operator, [1], exact_rhs!(viscosity), 2, 2; bonus_quadorder = 5))\n\n    # add grad-div stabilisation\n    if graddiv > 0\n        add_operator!(StokesProblem, [1,1], AbstractBilinearForm(\"graddiv-stabilisation (div x div)\", Divergence, Divergence, MultiplyScalarAction(graddiv)))\n    end\n\n    # define bestapproximation problems\n    L2PressureBestapproximationProblem = L2BestapproximationProblem(exact_pressure!, 2, 1; bestapprox_boundary_regions = [], bonus_quadorder = 5)\n    L2VelocityBestapproximationProblem = L2BestapproximationProblem(exact_velocity!, 2, 2; bestapprox_boundary_regions = [1,2,3,4], bonus_quadorder = 5)\n    H1VelocityBestapproximationProblem = H1BestapproximationProblem(exact_velocity_gradient!, exact_velocity!, 2, 2; bestapprox_boundary_regions = [1,2,3,4], bonus_quadorder = 5, bonus_quadorder_boundary = 5)\n\n    # define ItemIntegrators for L2/H1 error computation and arrays to store them\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(exact_velocity!, Identity, 2, 2; bonus_quadorder = 5, time = T)\n    L2PressureErrorEvaluator = L2ErrorIntegrator(exact_pressure!, Identity, 2, 1; bonus_quadorder = 5)\n    H1VelocityErrorEvaluator = L2ErrorIntegrator(exact_velocity_gradient!, Gradient, 2, 4; bonus_quadorder = 5, time = T)\n    L2error_velocity = []; L2error_pressure = []; NDofs = []\n    L2errorBestApproximation_velocity = []; L2errorBestApproximation_pressure = []\n    H1error_velocity = []; H1errorBestApproximation_velocity = []\n\n    # loop over levels\n    for level = 1 : nlevels\n\n        xgrid = uniform_refine(xgrid)\n\n        # generate FESpaces\n        FESpaceVelocity = FESpace{FETypes[1]}(xgrid)\n        FESpacePressure = FESpace{FETypes[2]}(xgrid)\n\n        # generate solution fector\n        Solution = FEVector{Float64}(\"Stokes velocity\",FESpaceVelocity)\n        append!(Solution,\"Stokes pressure\",FESpacePressure)\n        push!(NDofs,length(Solution.entries))\n\n        # set initial solution ( = bestapproximation at time 0)\n        L2VelocityBestapproximation = FEVector{Float64}(\"L2-Bestapproximation velocity\",FESpaceVelocity)\n        solve!(L2VelocityBestapproximation, L2VelocityBestapproximationProblem; time = 0)\n        Solution[1][:] = L2VelocityBestapproximation[1][:]\n\n        # generate time-dependent solver and chance rhs data\n        TCS = TimeControlSolver(StokesProblem, Solution, BackwardEuler; timedependent_equations = [1], maxlureuse = [-1], dt_testfunction_operator = [testfunction_operator], verbosity = verbosity)\n        advance_until_time!(TCS, timestep, T)\n\n        # solve bestapproximation problems at final time for comparison\n        L2PressureBestapproximation = FEVector{Float64}(\"L2-Bestapproximation pressure\",FESpacePressure)\n        H1VelocityBestapproximation = FEVector{Float64}(\"H1-Bestapproximation velocity\",FESpaceVelocity)\n        solve!(L2VelocityBestapproximation, L2VelocityBestapproximationProblem; time = T)\n        solve!(L2PressureBestapproximation, L2PressureBestapproximationProblem;)\n        solve!(H1VelocityBestapproximation, H1VelocityBestapproximationProblem; time = T)\n\n        # compute L2 and H1 error of all solutions\n        append!(L2error_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1])))\n        append!(L2errorBestApproximation_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,L2VelocityBestapproximation[1])))\n        append!(L2error_pressure,sqrt(evaluate(L2PressureErrorEvaluator,Solution[2])))\n        append!(L2errorBestApproximation_pressure,sqrt(evaluate(L2PressureErrorEvaluator,L2PressureBestapproximation[1])))\n        append!(H1error_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,Solution[1])))\n        append!(H1errorBestApproximation_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,H1VelocityBestapproximation[1])))\n\n        # ouput errors\n        if (level == nlevels)\n            println(\"\\n         |   L2ERROR      order   |   L2ERROR      order   \")\n            println(\"   NDOF  | VELO-STOKES            | VELO-L2BEST            \");\n            order = 0\n            for j=1:nlevels\n                if j > 1\n                    order = log(L2error_velocity[j-1]/L2error_velocity[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e \",L2error_velocity[j])\n                @printf(\"   %.3f   |\",order)\n                if j > 1\n                    order = log(L2errorBestApproximation_velocity[j-1]/L2errorBestApproximation_velocity[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\" %.5e \",L2errorBestApproximation_velocity[j])\n                @printf(\"   %.3f\\n\",order)\n            end\n            println(\"\\n         |   H1ERROR      order   |   H1ERROR      order   \")\n            println(\"   NDOF  | VELO-STOKES            | VELO-H1BEST            \");\n            order = 0\n            for j=1:nlevels\n                if j > 1\n                    order = log(H1error_velocity[j-1]/H1error_velocity[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e \",H1error_velocity[j])\n                @printf(\"   %.3f   |\",order)\n                if j > 1\n                    order = log(H1errorBestApproximation_velocity[j-1]/H1errorBestApproximation_velocity[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\" %.5e \",H1errorBestApproximation_velocity[j])\n                @printf(\"   %.3f\\n\",order)\n            end\n            println(\"\\n         |   L2ERROR      order   |   L2ERROR      order   \")\n            println(\"   NDOF  | PRES-STOKES            | PRES-L2BEST            \");\n            order = 0\n            for j=1:nlevels\n                if j > 1\n                    order = log(L2error_pressure[j-1]/L2error_pressure[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e \",L2error_pressure[j])\n                @printf(\"   %.3f   |\",order)\n                if j > 1\n                    order = log(L2errorBestApproximation_pressure[j-1]/L2errorBestApproximation_pressure[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\" %.5e \",L2errorBestApproximation_pressure[j])\n                @printf(\"   %.3f\\n\",order)\n            end\n            println(\"\\nLEGEND\\n======\")\n            println(\"VELO-STOKES : discrete Stokes velocity solution ($(FESpaceVelocity.name))\")\n            println(\"VELO-L2BEST : L2-Bestapproximation of exact velocity (with boundary data)\")\n            println(\"VELO-H1BEST : H1-Bestapproximation of exact velocity (with boudnary data)\")\n            println(\"PRES-STOKES : discrete Stokes pressure solution ($(FESpacePressure.name))\")\n            println(\"PRES-L2BEST : L2-Bestapproximation of exact pressure (without boundary data)\")\n\n            if Plotter != nothing\n                # plot grid\n                xgrid = split_grid_into(xgrid, Triangle2D)\n                ExtendableGrids.plot(xgrid; Plotter = Plotter)\n\n                # plot\n                GradientRobustMultiPhysics.plot(Solution, [1,2], [Identity, Identity]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\n            end\n        end\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_flowtransport/#D-Flow-Transport","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"","category":"section"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"(source code)","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"This example solve the Stokes problem in a Omega-shaped pipe and then uses the velocity in a transport equation for a species with a certain inlet concentration. Altogether, we are looking for a velocity mathbfu, a pressure mathbfp and a species concentration mathbfc such that","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"beginaligned\n- mu Delta mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\n- kappa Delta mathbfc + mathbfu cdot nabla mathbfc  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"with some viscosity parameter  and diffusion parameter kappa.","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"The diffusion coefficient for the species is chosen (almost) zero such that the isolines of the concentration should stay parallel from inlet to outlet. For the discretisation of the convection term in the transport equation two three possibilities can be chosen:","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"Classical finite element discretisations mathbfu_h cdot nabla mathbfc_h\nPressure-robust finite element discretisation Pi_textreconst mathbfu_h cdot nabla mathbfc_h with some divergence-free reconstruction operator Pi_textreconst\nUpwind finite volume discretisation for kappa = 0 based on normal fluxes along the faces (also divergence-free in finite volume sense)","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"Observe that a pressure-robust Bernardi–Raugel discretisation preserves this much better than a classical Bernardi–Raugel method. For comparison also a Taylor–Hood method can be switched on which is comparable to the pressure-robust lowest-order method in this example.","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"Note, that the transport equation is very convection-dominated and no stabilisation in the finite element discretisations was used here (but instead a nonzero kappa). The results are very sensitive to kappa and may be different if a stabilisation is used (work in progress). Also note, that only the finite volume discretisation perfectly obeys the maximum principle for the concentration but the isolines do no stay parallel until the outlet is reached, possibly due to articifial diffusion.","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"module Example_2DFlowTransport\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n\n# boundary data\nfunction inlet_velocity!(result,x)\n    result[1] = 4*x[2]*(1-x[2]);\n    result[2] = 0.0;\nend\nfunction inlet_concentration!(result,x)\n    result[1] = 1-x[2];\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1, Plotter = nothing, FVtransport = true, write_vtk = true)\n\n    # load mesh and refine\n    xgrid = simplexgrid(IOStream;file = \"assets/2d_grid_upipe.sg\")\n    xgrid = uniform_refine(xgrid,4)\n\n    # problem parameters\n    viscosity = 1 # coefficient for Stokes equation\n\n    # choose one of these (inf-sup stable) finite element type pairs for the flow\n    #FETypes = [H1P2{2,2}, H1P1{1}]; postprocess_operator = Identity # Taylor--Hood\n    #FETypes = [H1BR{2}, L2P0{1}]; postprocess_operator = Identity # Bernardi--Raugel\n    FETypes = [H1BR{2}, L2P0{1}]; postprocess_operator = ReconstructionIdentity{HDIVRT0{2}} # Bernardi--Raugel pressure-robust (RT0 reconstruction)\n    #FETypes = [H1BR{2}, L2P0{1}]; postprocess_operator = ReconstructionIdentity{HDIVBDM1{2}} # Bernardi--Raugel pressure-robust (BDM1 reconstruction)\n\n    #####################################################################################\n    #####################################################################################\n\n    # load Stokes problem prototype\n    # and assign boundary data (inlet profile in bregion 2, zero Dirichlet at walls 1 and nothing at outlet region 2)\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false, no_pressure_constraint = true)\n    Problem.name = \"Stokes + Transport\"\n    add_boundarydata!(Problem, 1, [1,3], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [4], BestapproxDirichletBoundary; data = inlet_velocity!, bonus_quadorder = 2)\n\n    # add transport equation of species\n    add_unknown!(Problem, 2, 1; unknown_name = \"concentration\", equation_name = \"transport equation\")\n    if FVtransport == true\n        # finite volume upwind discretisation\n        FETypeTransport = L2P0{1}\n        add_operator!(Problem, [3,3], FVConvectionDiffusionOperator(1))\n    else\n        # finite element convection and diffusion (very small) operators\n        FETypeTransport = H1P1{1}\n        diffusion_FE = 1e-7 # diffusion coefficient for transport equation\n        add_operator!(Problem, [3,3], LaplaceOperator(diffusion_FE,2,1))\n        add_operator!(Problem, [3,3], ConvectionOperator(1, postprocess_operator, 2, 1))\n    end\n    # with boundary data (i.e. inlet concentration)\n    add_boundarydata!(Problem, 3, [4], InterpolateDirichletBoundary; data = inlet_concentration!, bonus_quadorder = 0)\n    Base.show(Problem)\n\n    # generate FESpaces\n    FESpaceVelocity = FESpace{FETypes[1]}(xgrid)\n    FESpacePressure = FESpace{FETypes[2]}(xgrid)\n    FESpaceConcentration = FESpace{FETypeTransport}(xgrid)\n\n    # solve the decoupled flow problem\n    Solution = FEVector{Float64}(\"velocity\",FESpaceVelocity)\n    append!(Solution,\"pressure\",FESpacePressure)\n    append!(Solution,\"species concentration\",FESpaceConcentration)\n    solve!(Solution, Problem; subiterations = [[1,2]], verbosity = verbosity, maxIterations = 5, maxResidual = 1e-12)\n\n    # solve the transport by finite volumes or finite elements\n    if FVtransport == true\n        # pseudo-timestepping until stationarity detected, the matrix stays the same in each iteration\n        TCS = TimeControlSolver(Problem, Solution, BackwardEuler; subiterations = [[3]], maxlureuse = [-1], timedependent_equations = [3], verbosity = verbosity)\n        advance_until_stationarity!(TCS, 10000; maxTimeSteps = 100, stationarity_threshold = 1e-12)\n    else\n        # solve directly\n        solve!(Solution, Problem; subiterations = [[3]], verbosity = verbosity, maxIterations = 5, maxResidual = 1e-12)\n    end\n\n    # print minimal and maximal concentration\n    # (maximum principle says it should be [0,1])\n    println(\"\\n[min(c),max(c)] = [$(minimum(Solution[3][:])),$(maximum(Solution[3][:]))]\")\n\n    # plot\n    GradientRobustMultiPhysics.plot(Solution, [1,2,3], [Identity, Identity, Identity]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\n\n    if write_vtk\n        mkpath(\"data/example_flowtransport/\")\n        writeVTK!(\"data/example_flowtransport/results.vtk\", Solution)\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_3d_poisson/#D-Poisson-Problem","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"","category":"section"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"(source code)","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"This example computes the solution u of the three dimensional Poisson problem","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"with some right-hand side f on the unit cube domain Omega on a series of uniform refined meshes (tetrahedra or parallelepipeds).","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"module Example_3DPoisson\n\nusing GradientRobustMultiPhysics\nusing Printf\n\n# problem data\nfunction exact_function!(result,x)\n    result[1] = x[1]*(x[3] - x[2]) + x[2]*x[2]\n    return nothing\nend\nfunction exact_gradient!(result,x)\n    result[1] = x[3] - x[2]\n    result[2] = - x[1] + 2*x[2]\n    result[3] = x[1]\n    return nothing\nend\nfunction rhs!(result,x)\n    result[1] = - 2\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1)\n\n    # choose initial mesh\n    # (replace Parallelepiped3D by Tetrahedron3D to change the cell geometries)\n    xgrid_b = grid_unitcube(Parallelepiped3D)\n    nlevels = 5 # maximal number of refinement levels\n    split_into_tets = true # grid is split into Tetrahedron3D after each refinement of the basis grid\n    write_vtk = false\n\n    # set finite element type used for discretisation\n    FEType = H1P1{1}\n\n    # create Poisson problem via prototype and add data\n    Problem = PoissonProblem(3; diffusion = 1.0)\n    add_boundarydata!(Problem, 1, [1,2,3,4,5,6], BestapproxDirichletBoundary; data = exact_function!, bonus_quadorder = 2)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], rhs!, 3, 1; bonus_quadorder = 0))\n\n    # prepare error calculation\n    L2ErrorEvaluator = L2ErrorIntegrator(exact_function!, Identity, 3, 1; bonus_quadorder = 2)\n    H1ErrorEvaluator = L2ErrorIntegrator(exact_gradient!, Gradient, 3, 3; bonus_quadorder = 1)\n    L2error = []; H1error = []; NDofs = []\n\n    # loop over levels\n    for level = 1 : nlevels\n\n        # uniform mesh refinement\n        if level > 1\n            xgrid_b = uniform_refine(xgrid_b)\n        end\n        if split_into_tets\n            xgrid = split_grid_into(xgrid_b, Tetrahedron3D)\n        else\n            xgrid = xgrid_b\n        end\n\n        # create finite element space\n        FES = FESpace{FEType}(xgrid; dofmaps_needed = [CellDofs, BFaceDofs])\n\n        # solve the problem\n        Solution = FEVector{Float64}(\"Solution\",FES)\n        push!(NDofs,length(Solution.entries))\n        solve!(Solution, Problem; verbosity = verbosity)\n\n        # calculate L2 and H1 error\n        append!(L2error,sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\n        append!(H1error,sqrt(evaluate(H1ErrorEvaluator,Solution[1])))\n\n        if write_vtk\n            mkpath(\"data/example_poisson3d/\")\n            writeVTK!(\"data/example_poisson3d/results_level$(level).vtk\", Solution)\n        end\n\n    end\n\n    # output errors in a nice table\n    println(\"\\n   NDOF  |   L2ERROR   |   H1ERROR\")\n    for j=1:nlevels\n        @printf(\"  %6d |\",NDofs[j]);\n        @printf(\" %.5e |\",L2error[j])\n        @printf(\" %.5e\\n\",H1error[j])\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_cookmembrane/#D-Linear-Elasticity","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"","category":"section"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"(source code)","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"This example computes the solution mathbfu of the linear elasticity problem","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"beginaligned\n-mathrmdiv (mathbbC epsilon(mathbfu))  = mathbff quad textin  Omega\nmathbbC epsilon(mathbfu) cdot mathbfn  = mathbfg quad textalong  Gamma_N\nendaligned","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"with exterior force mathbff, Neumann boundary force mathbfg, and the stiffness tensor","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"mathbbC epsilon(mathbfu) = 2 mu epsilon( mathbfu) + lambda mathrmtr(epsilon( mathbfu))","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"for isotropic media.","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"The domain will be the Cook membrane and the displacement has homogeneous boundary conditions on the left side of the domain and Neumann boundary conditions (i.e. a force that pulls the domain downwards) on the right side.","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"module Example_2DCookMembrane\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# problem data for Neumann boundary\nfunction neumann_force_right!(result,x)\n    result[1] = 0.0\n    result[2] = 10.0\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1, Plotter = nothing)\n\n    # load mesh and refine\n    xgrid = simplexgrid(IOStream;file = \"assets/2d_grid_cookmembrane.sg\")\n    xgrid = uniform_refine(xgrid,2)\n\n    # problem parameters\n    elasticity_modulus = 1000 # elasticity modulus\n    poisson_number = 1//3 # Poisson number\n    shear_modulus = (1/(1+poisson_number))*elasticity_modulus\n    lambda = (poisson_number/(1-2*poisson_number))*shear_modulus\n\n    # choose finite element type\n    FEType = H1P1{2} # P1-Courant\n    #FEType = H1P2{2,2} # P2\n\n    #####################################################################################\n    #####################################################################################\n\n    # PDE description via prototype\n    LinElastProblem = LinearElasticityProblem(2; shear_modulus = shear_modulus, lambda = lambda)\n\n    # add Neumann boundary data\n    add_rhsdata!(LinElastProblem, 1,  RhsOperator(Identity, [2], neumann_force_right!, 2, 2; on_boundary = true, bonus_quadorder = 0))\n\n    # add Dirichlet boundary data\n    add_boundarydata!(LinElastProblem, 1, [4], HomogeneousDirichletBoundary)\n\n    # show problem definition\n    show(LinElastProblem)\n\n    # generate FESpace\n    FES = FESpace{FEType}(xgrid)\n\n    # solve PDE\n    Solution = FEVector{Float64}(\"displacement\",FES)\n    solve!(Solution, LinElastProblem; verbosity = verbosity)\n\n    # plot stress\n    GradientRobustMultiPhysics.plot(Solution, [1,1], [Identity, Gradient]; Plotter = Plotter, verbosity = verbosity, use_subplots = true)\n\nend\n\nend","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GradientRobustMultiPhysics.jl","page":"Home","title":"GradientRobustMultiPhysics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers (mostly low-order) finite element methods for multiphysics problems in Julia that focus on the preservation of structural and qualitative properties, in particular the gradient-robustness property for the discretisation of (nearly) incompressible flows and resulting qualitative properties in coupled processes. The code therefore offers several classical and novel non-standard finite element discretisations to play and compare with in these applications and a toolkit to setup multi-physics problems by defining PDE systems and generating fixed-point iterations to solve them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is based on ExtendableGrids.jl that allows to have unstructured grids with mixed element geometries in it, e.g. triangles and quads in the same mesh.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe focus is (at least currently) not on high-performance, high-order or parallel-computing. Also, this package is still in an early development stage with a limited number of applications and interfaces (especially in 3D and for time-dependent PDEs) and features might change in future updates.","category":"page"},{"location":"#What-is-gradient-robustness?","page":"Home","title":"What is gradient-robustness?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gradient-robustness is a feature of discretisations that exactly balance gradient forces in the momentum balance. In the case of the incompressible Navier–Stokes equations this means that the discrete velocity does not depend on the exact pressure. Divergence-conforming finite element methods have this property but are usually expensive and difficult to contruct. However, also non-divergence-conforming classical finite element methods can be made pressure-robust with the help of reconstruction operators applied to testfuntions in certain terms of the momentum balance, see e.g. references [1,2] below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Recently gradient-robustness was also connected to the design of well-balanced schemes e.g. in the context of (nearly) compressible flows, see e.g. reference [3] below.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"On the divergence constraint in mixed finite element methods for incompressible flows\",\n      V. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\n      SIAM Review 59(3) (2017), 492–544,\n      >Journal-Link<,       >Preprint-Link<\n[2]   \"Pressure-robustness and discrete Helmholtz projectors in mixed finite element methods for the incompressible Navier–Stokes equations\",\n      A. Linke and C. Merdon,       Computer Methods in Applied Mechanics and Engineering 311 (2016), 304–326,\n      >Journal-Link<       >Preprint-Link<\n[3]   \"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\n      M. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\n      Computer Methods in Applied Mechanics and Engineering 367 (2020),\n      >Journal-Link<       >Preprint-Link<","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nExtendableSparse.jl\nDocStringExtensions.jl\nForwardDiff.jl\nDiffResults.jl\nBenchmarkTools.jl","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The general work-flow is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Describe your PDE system with the help of the PDE Description (possibly based on one of the PDE Prototypes). Additional parameters or non-constant parameters or non-standard terms (like stabilisations) in the weak form can be added manually afterwards.\nGenerate a mesh (possibly using one of the constructors by ExtendableGrid.jl) and assign boundary and right-hand side data matching the boundary regions and regions in the mesh (see PDE Description again for details).\nDefine finite element ansatz spaces (see Finite Element Spaces and Arrays for details) for the unknowns of your PDE system.\nSolve by using solve! or via a TimeControlSolver and advance! if the PDE system is time-dependent (see PDE Solvers for details).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please have a look at the Examples.","category":"page"}]
}
